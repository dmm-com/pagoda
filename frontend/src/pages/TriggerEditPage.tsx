import {
  EntryAttributeTypeTypeEnum,
  TriggerParentUpdate,
} from "@dmm-com/airone-apiclient-typescript-fetch";
import { zodResolver } from "@hookform/resolvers/zod";
import {
  Autocomplete,
  Box,
  Container,
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableRow,
  TextField,
  Typography,
} from "@mui/material";
import { styled } from "@mui/material/styles";
import { FC, useCallback, useEffect, useState } from "react";
import { Controller, useForm } from "react-hook-form";
import { useNavigate } from "react-router";

import type { TriggerActionUpdate } from "@dmm-com/airone-apiclient-typescript-fetch/src/autogenerated/models/TriggerActionUpdate";

import { AironeLink } from "components";
import { AironeBreadcrumbs } from "components/common/AironeBreadcrumbs";
import { PageHeader } from "components/common/PageHeader";
import { SubmitButton } from "components/common/SubmitButton";
import { Actions } from "components/trigger/Actions";
import { Conditions } from "components/trigger/Conditions";
import { Schema, schema } from "components/trigger/TriggerFormSchema";
import { useAsyncWithThrow } from "hooks/useAsyncWithThrow";
import { useFormNotification } from "hooks/useFormNotification";
import { usePrompt } from "hooks/usePrompt";
import { useTypedParams } from "hooks/useTypedParams";
import { aironeApiClient } from "repository/AironeApiClient";
import { topPath, triggersPath } from "routes/Routes";

const StyledFlexColumnBox = styled(Box)({
  display: "flex",
  flexDirection: "column",
  alignItems: "center",
  marginBottom: "48px",
});

const HeaderTableRow = styled(TableRow)(({ }) => ({
  backgroundColor: "#455A64",
}));

const HeaderTableCell = styled(TableCell)(({ }) => ({
  color: "#FFFFFF",
  boxSizing: "border-box",
}));

const StyledTableBody = styled(TableBody)({
  "tr:nth-of-type(odd)": {
    backgroundColor: "white",
  },
  "tr:nth-of-type(even)": {
    backgroundColor: "#607D8B0A",
  },
  "& td": {
    padding: "8px",
  },
});

export const TriggerEditPage: FC = () => {
  const { triggerId } = useTypedParams<{ triggerId: number }>();
  const willCreate = triggerId === undefined;

  const navigate = useNavigate();
  const { enqueueSubmitResult } = useFormNotification("トリガー", willCreate);

  const actionTrigger = useAsyncWithThrow(async () => {
    if (triggerId !== undefined) {
      // set valid for actionTrigger context when opening edit page
      return await aironeApiClient.getTrigger(triggerId);
    } else {
      return undefined;
    }
  }, []);

  const {
    formState: { isDirty, isValid, isSubmitting, isSubmitSuccessful },
    handleSubmit,
    reset,
    setError,
    setValue,
    getValues,
    trigger,
    control,
  } = useForm<Schema>({
    resolver: zodResolver(schema),
    mode: "onBlur",
    defaultValues: {
      id: 0,
    },
  });

  usePrompt(
    isDirty && !isSubmitSuccessful,
    "編集した内容は失われてしまいますが、このページを離れてもよろしいですか？",
  );

  const entities = useAsyncWithThrow(async () => {
    const entities = await aironeApiClient.getEntities();
    return entities.results;
  });

  const [entityId, setEntityId] = useState<number>();
  const entity = useAsyncWithThrow(async () => {
    if (entityId) {
      return await aironeApiClient.getEntity(entityId);
    } else {
      return undefined;
    }
  }, [entityId]);

  const convertConditions2ServerFormat = (trigger: Schema) => {
    if (!entity.value) {
      return [];
    }

    return trigger.conditions.flatMap((cond) => {
      const attrInfo = entity.value?.attrs.find(
        (attr) => attr.id === cond.attr.id,
      );

      switch (attrInfo?.type) {
        case EntryAttributeTypeTypeEnum.STRING:
        case EntryAttributeTypeTypeEnum.ARRAY_STRING:
          return { attrId: cond.attr.id, cond: cond.strCond ?? "" };

        case EntryAttributeTypeTypeEnum.BOOLEAN:
          return { attrId: cond.attr.id, cond: String(cond.boolCond) };

        case EntryAttributeTypeTypeEnum.OBJECT:
        case EntryAttributeTypeTypeEnum.ARRAY_OBJECT:
          return { attrId: cond.attr.id, cond: String(cond.refCond?.id ?? 0) };

        case EntryAttributeTypeTypeEnum.NAMED_OBJECT:
        case EntryAttributeTypeTypeEnum.ARRAY_NAMED_OBJECT:
          return [
            {
              attrId: cond.attr.id,
              cond: JSON.stringify({
                name: cond.strCond,
                id: cond.refCond?.id ?? 0,
              }),
              hint: "json",
            },
          ];

        default:
          return { attrId: cond.attr.id, cond: "" };
      }
    });
  };

  const convertActions2ServerFormat = (
    trigger: Schema,
  ): TriggerActionUpdate[] => {
    if (!entity.value) {
      return [];
    }

    return trigger.actions.flatMap((action): TriggerActionUpdate[] => {
      const attrInfo = entity.value?.attrs.find(
        (attr) => attr.id === action.attr.id,
      );

      switch (attrInfo?.type) {
        case EntryAttributeTypeTypeEnum.STRING:
          return action.values.map((val) => ({
            attrId: action.attr.id,
            value: val.strCond ?? "",
          }));

        case EntryAttributeTypeTypeEnum.ARRAY_STRING:
          return [
            {
              attrId: action.attr.id,
              values: action.values.map((val) => val.strCond ?? ""),
            },
          ];

        case EntryAttributeTypeTypeEnum.BOOLEAN:
          return action.values.map((val) => ({
            attrId: action.attr.id,
            value: String(val.boolCond),
          }));

        case EntryAttributeTypeTypeEnum.OBJECT:
          return action.values.map((val) => ({
            attrId: action.attr.id,
            value: String(val.refCond?.id ?? 0),
          }));

        case EntryAttributeTypeTypeEnum.NAMED_OBJECT:
          return action.values.map((val) => ({
            attrId: action.attr.id,
            value: {
              name: val.strCond,
              id: val.refCond?.id ?? 0,
            },
          }));

        case EntryAttributeTypeTypeEnum.ARRAY_OBJECT:
          return [
            {
              attrId: action.attr.id,
              values: action.values
                .filter((val) => val.refCond && val.refCond?.id > 0)
                .map((val) => String(val.refCond?.id ?? 0)),
            },
          ];

        case EntryAttributeTypeTypeEnum.ARRAY_NAMED_OBJECT:
          return [
            {
              attrId: action.attr.id,
              values: action.values.map((val) => ({
                name: val.strCond,
                id: val.refCond?.id ?? 0,
              })),
            },
          ];
      }

      return [];
    });
  };

  const handleSubmitOnValid = useCallback(
    async (trigger: Schema) => {
      const triggerCreateUpdate: TriggerParentUpdate = {
        id: triggerId,
        entityId: trigger.entity.id,
        conditions: convertConditions2ServerFormat(trigger) ?? [],
        actions: convertActions2ServerFormat(trigger) ?? [],
      };
      try {
        if (triggerId !== undefined) {
          await aironeApiClient.updateTrigger(triggerId, triggerCreateUpdate);
          enqueueSubmitResult(true);
        } else {
          await aironeApiClient.createTrigger(triggerCreateUpdate);
          enqueueSubmitResult(true);
        }
      } catch (e) {
        const errMsg = "Failed to submit trigger";

        enqueueSubmitResult(false, errMsg);
        setError("conditions", { message: errMsg });
      }
    },
    [triggerId, entity],
  );

  const handleCancel = async () => {
    navigate(-1);
  };

  useEffect(() => {
    if (!actionTrigger.loading && actionTrigger.value != null) {
      // set defult value to React-hook-form
      reset(actionTrigger.value);

      setEntityId(actionTrigger.value.entity.id);

      trigger();
    }
  }, [actionTrigger.loading]);

  useEffect(() => {
    if (entity.value && entity.value.id !== 0) {
      setValue(
        `entity`,
        {
          id: entity.value.id,
          name: entity.value.name,
        },
        {
          shouldValidate: true,
        },
      );
    }
    trigger();
  }, [entity.loading]);

  useEffect(() => {
    if (isSubmitSuccessful) {
      navigate(triggersPath(), { replace: true });
    }
  }, [isSubmitSuccessful]);

  return (
    <Box>
      <AironeBreadcrumbs>
        <Typography component={AironeLink} to={topPath()}>
          Top
        </Typography>
        <Typography component={AironeLink} to={triggersPath()}>
          トリガー管理
        </Typography>
        <Typography color="textPrimary">
          {triggerId ? "編集" : "作成"}
        </Typography>
      </AironeBreadcrumbs>

      <PageHeader
        title={
          triggerId && entity.value ? entity.value.name : "新規トリガーの作成"
        }
        description={triggerId ? entity.value && "トリガー編集" : ""}
      >
        <SubmitButton
          name="保存"
          disabled={!isDirty || !isValid || isSubmitting || isSubmitSuccessful}
          isSubmitting={isSubmitting}
          handleSubmit={handleSubmit(handleSubmitOnValid)}
          handleCancel={handleCancel}
        />
      </PageHeader>

      <Container>
        <StyledFlexColumnBox>
          <Typography variant="h4">設定対象のモデル</Typography>

          <Controller
            name={`entity`}
            control={control}
            render={({ field }) => (
              <Autocomplete
                value={field.value ?? null}
                options={entities.value ?? []}
                getOptionLabel={(option: { id: number; name: string }) =>
                  option.name
                }
                isOptionEqualToValue={(option, value) => option.id === value.id}
                disabled={entities.loading}
                onChange={(_, value: { id: number; name: string } | null) => {
                  if (value && value.id != entityId) {
                    // set EntityId to state variable
                    setEntityId(value.id);

                    // reset whole information conditions and actions because of changing Entity
                    reset({
                      ...getValues(),
                      entity: value,
                      conditions: [],
                      actions: [],
                    });
                  }
                }}
                renderInput={(params) => (
                  <TextField
                    {...params}
                    variant="outlined"
                    placeholder="モデルを選択"
                  />
                )}
                fullWidth
              />
            )}
          />
        </StyledFlexColumnBox>

        {/* Trigger configuration forms should be shown after target entity is defined */}
        {entity.value && (
          <>
            <StyledFlexColumnBox>
              <Typography variant="h4" align="center" my="32px">
                条件
              </Typography>
              <Table data-testid="conditions">
                <TableHead>
                  <HeaderTableRow>
                    <HeaderTableCell width="400px">属性名</HeaderTableCell>
                    <HeaderTableCell width="100px">NOT</HeaderTableCell>
                    <HeaderTableCell width="300px">値</HeaderTableCell>
                    <HeaderTableCell width="100px">削除</HeaderTableCell>
                    <HeaderTableCell width="100px">追加</HeaderTableCell>
                  </HeaderTableRow>
                </TableHead>
                <StyledTableBody>
                  {entity.value && (
                    <Conditions control={control} entity={entity.value} />
                  )}
                </StyledTableBody>
              </Table>
            </StyledFlexColumnBox>

            <StyledFlexColumnBox>
              <Typography variant="h4" align="center" my="32px">
                アクション
              </Typography>
              <Table data-testid="actions">
                <TableHead>
                  <HeaderTableRow>
                    <HeaderTableCell width="400px">属性名</HeaderTableCell>
                    <HeaderTableCell width="400px">値</HeaderTableCell>
                    <HeaderTableCell width="100px">削除</HeaderTableCell>
                    <HeaderTableCell width="100px">追加</HeaderTableCell>
                  </HeaderTableRow>
                </TableHead>
                <StyledTableBody>
                  {entity.value && (
                    <Actions control={control} entity={entity.value} />
                  )}
                </StyledTableBody>
              </Table>
            </StyledFlexColumnBox>
          </>
        )}
      </Container>
    </Box>
  );
};
