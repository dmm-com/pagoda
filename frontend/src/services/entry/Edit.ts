import {
  Attribute,
  EntityDetail,
  EntryAttributeType,
  EntryAttributeValueObject,
  EntryRetrieve,
} from "apiclient/autogenerated";
import {
  EditableEntry,
  EditableEntryAttrs,
} from "components/entry/entryForm/EditableEntry";
import { DjangoContext } from "services/DjangoContext";

interface asArrayNamedObjectBoolean {
  [key: string]: EntryAttributeValueObject & {
    boolean: boolean;
  };
}

const djangoContext = DjangoContext.getInstance();

export function updateEntryInfoValueFromValueInfo(
  entryInfo: EditableEntry,
  attrName: string,
  attrType: number,
  valueInfo: any
): void {
  switch (attrType) {
    case djangoContext?.attrTypeValue.date:
    case djangoContext?.attrTypeValue.string:
    case djangoContext?.attrTypeValue.text:
      entryInfo.attrs[attrName].value.asString = valueInfo.value;
      break;

    case djangoContext?.attrTypeValue.boolean:
      entryInfo.attrs[attrName].value.asBoolean = valueInfo.checked;
      break;

    case djangoContext?.attrTypeValue.object:
      entryInfo.attrs[attrName].value.asObject = valueInfo.value;
      break;

    case djangoContext?.attrTypeValue.group:
      entryInfo.attrs[attrName].value.asGroup = valueInfo.value;
      break;

    case djangoContext?.attrTypeValue.role:
      entryInfo.attrs[attrName].value.asRole = valueInfo.value;
      break;

    case djangoContext?.attrTypeValue.named_object:
      if (valueInfo?.key !== undefined) {
        entryInfo.attrs[attrName].value.asNamedObject = {
          [valueInfo.key]:
            Object.values(
              entryInfo.attrs[attrName].value.asNamedObject ?? {}
            )[0] ?? null,
        };
      } else {
        entryInfo.attrs[attrName].value.asNamedObject = {
          [Object.keys(
            entryInfo.attrs[attrName].value.asNamedObject ?? {}
          )[0] ?? ""]: valueInfo.value,
        };
      }
      break;

    case djangoContext?.attrTypeValue.array_string:
      if (entryInfo.attrs[attrName].value?.asArrayString == null) {
        entryInfo.attrs[attrName].value.asArrayString = [];
      }
      // @ts-ignore
      entryInfo.attrs[attrName].value.asArrayString[valueInfo.index] =
        valueInfo.value;
      break;

    case djangoContext?.attrTypeValue.array_object:
      entryInfo.attrs[attrName].value.asArrayObject = valueInfo.value;
      break;

    case djangoContext?.attrTypeValue.array_group:
      entryInfo.attrs[attrName].value.asArrayGroup = valueInfo.value;
      break;

    case djangoContext?.attrTypeValue.array_role:
      entryInfo.attrs[attrName].value.asArrayRole = valueInfo.value;
      break;

    case djangoContext?.attrTypeValue.array_named_object:
      if (
        entryInfo.attrs[attrName].value.asArrayNamedObject?.length ??
        0 <= valueInfo.index
      ) {
        entryInfo.attrs[attrName].value.asArrayNamedObject?.push({
          // @ts-ignore
          "": null,
        });
        break;
      }

      if (valueInfo?.key !== undefined) {
        // @ts-ignore
        entryInfo.attrs[attrName].value.asArrayNamedObject[valueInfo.index] = {
          [valueInfo.key]:
            Object.values(
              entryInfo.attrs[attrName].value.asArrayNamedObject?.[
                valueInfo.index
              ] ?? {}
            )[0] ?? null,
        };
      } else {
        const INPUT_NAME =
          Object.keys(
            entryInfo.attrs[attrName].value.asArrayNamedObject?.[
              valueInfo.index
            ] ?? {}
          )[0] ?? "";

        const REFER_ENTRY = Object.values(
          entryInfo.attrs[attrName].value.asArrayNamedObject?.[
            valueInfo.index
          ] ?? {}
        )[0];

        // @ts-ignore
        entryInfo.attrs[attrName].value.asArrayNamedObject[valueInfo.index] = {
          [INPUT_NAME]: {
            ...REFER_ENTRY,
            id: valueInfo.value.id,
            name: valueInfo.value.name,
          },
        };
      }
      break;

    case djangoContext?.attrTypeValue.array_named_object_boolean:
      (
        entryInfo.attrs[attrName].value
          .asArrayNamedObject as asArrayNamedObjectBoolean[]
      )[valueInfo.index] = {
        [Object.keys(
          entryInfo.attrs[attrName].value.asArrayNamedObject?.[
            valueInfo.index
          ] ?? {}
        )[0] ?? ""]: {
          ...Object.values(
            entryInfo.attrs[attrName].value.asArrayNamedObject?.[
              valueInfo.index
            ] ?? {}
          )[0],
          boolean: valueInfo.checked,
        },
      };

      break;
  }
}

// Convert Entry information from server-side value to presentation format.
// (NOTE) It might be needed to be refactored because if server returns proper format with frontend, this is not necessary.
export function formalizeEntryInfo(
  entry: EntryRetrieve,
  excludeAttrs: string[]
) {
  return {
    name: entry.name,
    attrs: Object.fromEntries(
      entry.attrs
        .filter((attr) => !excludeAttrs.includes(attr.schema.name))
        .filter((attr) => attr.schema.id != 0)
        .map((attr): [string, EditableEntryAttrs] => {
          function getAttrValue(attr: EntryAttributeType) {
            switch (attr.type) {
              case djangoContext?.attrTypeValue.array_string:
                return attr.value?.asArrayString?.length ?? 0 > 0
                  ? attr.value
                  : { asArrayString: [""] };
              case djangoContext?.attrTypeValue.array_named_object:
                return attr.value?.asArrayNamedObject?.length ?? 0 > 0
                  ? attr.value
                  : { asArrayNamedObject: [{ "": null }] };
              default:
                return attr.value;
            }
          }

          return [
            attr.schema.name,
            {
              id: attr.id,
              type: attr.type,
              isMandatory: attr.isMandatory,
              schema: attr.schema,
              // FIXME it mismatches client/server defined types
              // @ts-ignore
              value: getAttrValue(attr),
            },
          ];
        })
    ),
  };
}

export function initializeEntryInfo(entity: EntityDetail) {
  // FIXME remove ts-ignore's, maybe we should refine server defined types
  return {
    name: "",
    attrs: Object.fromEntries(
      entity.attrs.map((attr): [string, EditableEntryAttrs] => [
        attr?.name ?? "",
        {
          // @ts-ignore
          id: attr.id,
          // @ts-ignore
          type: attr.type,
          isMandatory: attr.isMandatory ?? false,
          schema: {
            // @ts-ignore
            id: attr.id,
            // @ts-ignore
            name: attr.name,
          },
          value: {
            asString: "",
            asBoolean: false,
            asObject: undefined,
            asGroup: undefined,
            asRole: undefined,
            asNamedObject: {},
            asArrayString: [""],
            asArrayObject: [],
            asArrayGroup: [],
            asArrayRole: [],
            asArrayNamedObject: [{}],
          },
        },
      ])
    ),
  };
}

export function isSubmittable(entryInfo: EditableEntry): boolean {
  return Object.entries(entryInfo?.attrs ?? {})
    .filter(([{}, attrValue]) => attrValue.isMandatory)
    .map((attr) =>
      [
        // TODO support role-like types
        attr[1].type === djangoContext?.attrTypeValue.boolean,
        attr[1].value.asString?.length,
        attr[1].value.asObject,
        attr[1].value.asGroup,
        attr[1].value.asRole,
        Object.keys(attr[1].value.asNamedObject ?? {})[0] &&
          Object.values(attr[1].value.asNamedObject ?? {})[0],
        attr[1].value.asArrayString?.filter((v) => v).length,
        attr[1].value.asArrayObject?.filter((v) => v).length,
        attr[1].value.asArrayGroup?.filter((v) => v).length,
        attr[1].value.asArrayRole?.filter((v) => v).length,
        attr[1].value.asArrayNamedObject?.filter(
          (v) => Object.keys(v)[0] && Object.values(v)[0]
        ).length,
      ].some((value) => value)
    )
    .every((value) => value);
}

export function convertAttrsFormatCtoS(
  attrs: Record<string, EditableEntryAttrs>
): Attribute[] {
  return Object.entries(attrs ?? {}).map(([{}, attrValue]) => {
    switch (attrValue.type) {
      case djangoContext?.attrTypeValue.string:
      case djangoContext?.attrTypeValue.text:
      case djangoContext?.attrTypeValue.date:
        return {
          id: attrValue.schema.id,
          value: attrValue.value.asString,
        };

      case djangoContext?.attrTypeValue.boolean:
        return {
          id: attrValue.schema.id,
          value: attrValue.value.asBoolean,
        };

      case djangoContext?.attrTypeValue.object:
        return {
          id: attrValue.schema.id,
          value: attrValue.value.asObject?.id ?? null,
        };

      case djangoContext?.attrTypeValue.group:
        return {
          id: attrValue.schema.id,
          value: attrValue.value.asGroup?.id ?? null,
        };

      case djangoContext?.attrTypeValue.role:
        return {
          id: attrValue.schema.id,
          value: attrValue.value.asRole?.id ?? null,
        };

      case djangoContext?.attrTypeValue.named_object:
        return {
          id: attrValue.schema.id,
          value: {
            id:
              Object.values(attrValue.value.asNamedObject ?? {})[0]?.id ?? null,
            name: Object.keys(attrValue.value.asNamedObject ?? {})[0] ?? "",
          },
        };

      case djangoContext?.attrTypeValue.array_string:
        return {
          id: attrValue.schema.id,
          value: attrValue.value.asArrayString,
        };

      case djangoContext?.attrTypeValue.array_object:
        return {
          id: attrValue.schema.id,
          value: attrValue.value.asArrayObject?.map((x) => x.id),
        };

      case djangoContext?.attrTypeValue.array_group:
        return {
          id: attrValue.schema.id,
          value: attrValue.value.asArrayGroup?.map((x) => x.id),
        };

      case djangoContext?.attrTypeValue.array_role:
        return {
          id: attrValue.schema.id,
          value: attrValue.value.asArrayRole?.map((x) => x.id),
        };

      case djangoContext?.attrTypeValue.array_named_object:
        return {
          id: attrValue.schema.id,
          value: attrValue.value.asArrayNamedObject?.map((x) => {
            return {
              id: Object.values(x)[0]?.id ?? null,
              name: Object.keys(x)[0] ?? "",
            };
          }),
        };

      case djangoContext?.attrTypeValue.array_named_object_boolean:
        return {
          id: attrValue.schema.id,
          value: (
            attrValue.value.asArrayNamedObject as {
              [key: string]: Pick<
                EntryAttributeValueObject,
                "id" | "name" | "schema"
              > & {
                boolean?: boolean;
              };
            }[]
          )?.map((x) => {
            return {
              id: Object.values(x)[0]?.id ?? null,
              name: Object.keys(x)[0] ?? "",
              boolean: Object.values(x)[0]?.boolean ?? false,
            };
          }),
        };

      default:
        throw new Error(`unknown attribute type ${attrValue.type}`);
    }
  });
}
