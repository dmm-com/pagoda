"use strict";(function(){const t={};t.doc={id:"id",field:["title","content"],store:["title","href","parent"]};const e=FlexSearch.create(t);window.geekdocSearchIndex=e,e.add({id:0,href:"/advanced/plugin_architecture_diagrams/",title:"Plugin System Architecture Diagrams",parent:"Advanced Topics",content:`System Architecture Overview 3-Layer Architecture Flow graph TB subgraph \u0026#34;Layer 1: Core Framework (pagoda-plugin-sdk)\u0026#34; PC[pagoda-plugin-sdk Package] PI[Plugin Interfaces] PB[Base Plugin Class] CH[Common Hooks] AM[API Mixins] end subgraph \u0026#34;Layer 2: External Plugin\u0026#34; EP[External Plugin Package] PL[Plugin Logic] API[API Endpoints] HH[Hook Handlers] DJ[Django App Config] end subgraph \u0026#34;Layer 3: Pagoda Host Application\u0026#34; MI[Model Injection] PI_SYS[Plugin Integration] UI[URL Integration] AS[Pagoda Settings] DM[Django Models] end PC --\u0026gt; EP PI --\u0026gt; EP PB --\u0026gt; EP CH --\u0026gt; EP AM --\u0026gt; EP EP --\u0026gt; MI EP --\u0026gt; PI_SYS EP --\u0026gt; UI EP --\u0026gt; AS DM --\u0026gt; MI MI --\u0026gt; PC style PC fill:#e1f5fe style EP fill:#f3e5f5 style MI fill:#e8f5e8 Plugin Discovery \u0026amp; Registration Flow sequenceDiagram participant ENV as Environment participant AI as Pagoda Init participant PD as Plugin Discovery participant PR as Plugin Registry participant MI as Model Injection participant DU as Django URLs ENV-\u0026gt;\u0026gt;AI: ENABLED_PLUGINS=hello-world AI-\u0026gt;\u0026gt;PD: Start plugin discovery par External Plugin Discovery PD-\u0026gt;\u0026gt;PD: pkg_resources.iter_entry_points(\u0026#39;pagoda.plugins\u0026#39;) PD-\u0026gt;\u0026gt;PR: Register external plugins and Example Plugin Discovery PD-\u0026gt;\u0026gt;PD: Scan plugin/examples/ directory PD-\u0026gt;\u0026gt;PR: Register example plugins end PR-\u0026gt;\u0026gt;MI: Initialize model injection MI-\u0026gt;\u0026gt;MI: Inject Entity, Entry, User models PR-\u0026gt;\u0026gt;PR: Register plugin hooks PR-\u0026gt;\u0026gt;DU: Integrate URL patterns DU-\u0026gt;\u0026gt;AI: Plugin endpoints available Note over ENV,AI: Plugin system ready Hook System Architecture graph LR subgraph \u0026#34;Hook Registration\u0026#34; PC[pagoda-plugin-sdk\u0026lt;br/\u0026gt;17 Standard Hooks] AH[Legacy Aliases\u0026lt;br/\u0026gt;HOOK_ALIASES] HR[Hook Manager\u0026lt;br/\u0026gt;Registry] end subgraph \u0026#34;Plugin Implementation\u0026#34; PH[Plugin Hook\u0026lt;br/\u0026gt;Handlers] DEC[\u0026#34;Decorators\u0026lt;br/\u0026gt;entry_hook, entity_hook\u0026#34;] end subgraph \u0026#34;Execution Flow\u0026#34; DS[Django Signals] HE[Hook Executor] CB[Plugin Callbacks] ER[Error Isolation] end PC --\u0026gt; HR AH --\u0026gt; HR HR --\u0026gt; HE DEC --\u0026gt; PH PH --\u0026gt; CB DS --\u0026gt; HE HE --\u0026gt; CB CB --\u0026gt; ER style PC fill:#e1f5fe style PH fill:#f3e5f5 style HE fill:#e8f5e8 Hook Manager Detailed Architecture graph TB subgraph \u0026#34;Hook Registration Phase\u0026#34; PLUGIN[Plugin Class] DECO[Decorator Metadata] SCAN[__init_subclass__\u0026lt;br/\u0026gt;Auto-scan] META[_hook_handlers\u0026lt;br/\u0026gt;List] end subgraph \u0026#34;Hook Manager\u0026#34; REG[register_hook] HOOKS[_hooks Dict\u0026lt;br/\u0026gt;hook_name -\u0026gt; handlers] SORT[Priority Sorting] end subgraph \u0026#34;Hook Execution Phase\u0026#34; EXEC[execute_hook] NORM[Normalize Name\u0026lt;br/\u0026gt;Handle Aliases] FILT[Entity Filter] PRIOR[Priority Order] CALL[Call Handlers] ERR[Error Handling] end PLUGIN --\u0026gt; DECO DECO --\u0026gt; SCAN SCAN --\u0026gt; META META --\u0026gt; REG REG --\u0026gt; HOOKS HOOKS --\u0026gt; SORT EXEC --\u0026gt; NORM NORM --\u0026gt; FILT FILT --\u0026gt; PRIOR PRIOR --\u0026gt; CALL CALL --\u0026gt; ERR style PLUGIN fill:#e1f5fe style HOOKS fill:#f3e5f5 style EXEC fill:#fff3e0 style ERR fill:#ffebee Hook Execution Flow with Entity Filtering sequenceDiagram participant App as Application participant HM as Hook Manager participant P1 as Plugin A\u0026lt;br/\u0026gt;(entity=\u0026#34;customer\u0026#34;) participant P2 as Plugin B\u0026lt;br/\u0026gt;(all entities) participant P3 as Plugin C\u0026lt;br/\u0026gt;(entity=\u0026#34;customer\u0026#34;) App-\u0026gt;\u0026gt;HM: execute_hook(\u0026#34;entry.after_create\u0026#34;, entity_name=\u0026#34;customer\u0026#34;) HM-\u0026gt;\u0026gt;HM: Normalize hook name HM-\u0026gt;\u0026gt;HM: Get handlers for \u0026#34;entry.after_create\u0026#34; HM-\u0026gt;\u0026gt;HM: Filter by entity=\u0026#34;customer\u0026#34; Note over HM: Found 3 handlers:\u0026lt;br/\u0026gt;Plugin A (priority 50, entity=\u0026#34;customer\u0026#34;)\u0026lt;br/\u0026gt;Plugin B (priority 100, all entities)\u0026lt;br/\u0026gt;Plugin C (priority 150, entity=\u0026#34;customer\u0026#34;) HM-\u0026gt;\u0026gt;P1: Execute (priority 50) P1--\u0026gt;\u0026gt;HM: Success HM-\u0026gt;\u0026gt;P2: Execute (priority 100) P2--\u0026gt;\u0026gt;HM: Success HM-\u0026gt;\u0026gt;P3: Execute (priority 150) P3--\u0026gt;\u0026gt;HM: Success HM--\u0026gt;\u0026gt;App: All handlers executed Note over App,HM: If entity_name=\u0026#34;product\u0026#34;,\u0026lt;br/\u0026gt;only Plugin B would be called Decorator-Based Hook Registration graph TB subgraph \u0026#34;Plugin Definition\u0026#34; CLASS[Plugin Class\u0026lt;br/\u0026gt;MyPlugin] DEC1[\u0026#34;entry_hook\u0026lt;br/\u0026gt;after_create\u0026#34;] DEC2[\u0026#34;entity_hook\u0026lt;br/\u0026gt;after_create\u0026#34;] DEC3[\u0026#34;validation_hook\u0026#34;] DEC4[\u0026#34;get_attrs_hook\u0026lt;br/\u0026gt;entry\u0026#34;] METHOD1[handler method 1] METHOD2[handler method 2] METHOD3[handler method 3] METHOD4[handler method 4] end subgraph \u0026#34;Metaclass Processing\u0026#34; INIT[__init_subclass__] SCAN[Scan class methods] CHECK[Check for _hook_metadata] COLLECT[Collect to _hook_handlers] end subgraph \u0026#34;Registration\u0026#34; INST[Plugin Instance] REG[registry.register] HOOK_REG[Register each hook] HM[Hook Manager] end CLASS --\u0026gt; DEC1 --\u0026gt; METHOD1 CLASS --\u0026gt; DEC2 --\u0026gt; METHOD2 CLASS --\u0026gt; DEC3 --\u0026gt; METHOD3 CLASS --\u0026gt; DEC4 --\u0026gt; METHOD4 METHOD1 --\u0026gt; INIT METHOD2 --\u0026gt; INIT METHOD3 --\u0026gt; INIT METHOD4 --\u0026gt; INIT INIT --\u0026gt; SCAN SCAN --\u0026gt; CHECK CHECK --\u0026gt; COLLECT COLLECT --\u0026gt; INST INST --\u0026gt; REG REG --\u0026gt; HOOK_REG HOOK_REG --\u0026gt; HM style CLASS fill:#e1f5fe style INIT fill:#f3e5f5 style HM fill:#e8f5e8 Priority-Based Execution Order graph LR subgraph \u0026#34;Hook: entry.after_create\u0026#34; H1[Plugin A\u0026lt;br/\u0026gt;priority: 50\u0026lt;br/\u0026gt;entity: customer] H2[Plugin B\u0026lt;br/\u0026gt;priority: 75\u0026lt;br/\u0026gt;entity: *] H3[Plugin C\u0026lt;br/\u0026gt;priority: 100\u0026lt;br/\u0026gt;entity: customer] H4[Plugin D\u0026lt;br/\u0026gt;priority: 100\u0026lt;br/\u0026gt;entity: *] H5[Plugin E\u0026lt;br/\u0026gt;priority: 150\u0026lt;br/\u0026gt;entity: customer] end subgraph \u0026#34;Execution Sequence\u0026#34; E1[1st: Plugin A\u0026lt;br/\u0026gt;priority 50] E2[2nd: Plugin B\u0026lt;br/\u0026gt;priority 75] E3[3rd: Plugin C\u0026lt;br/\u0026gt;priority 100] E4[4th: Plugin D\u0026lt;br/\u0026gt;priority 100] E5[5th: Plugin E\u0026lt;br/\u0026gt;priority 150] end H1 -.lower priority\u0026lt;br/\u0026gt;executes first.-\u0026gt; E1 H2 --\u0026gt; E2 H3 --\u0026gt; E3 H4 --\u0026gt; E4 H5 -.higher priority\u0026lt;br/\u0026gt;executes last.-\u0026gt; E5 style H1 fill:#c8e6c9 style H2 fill:#c8e6c9 style H3 fill:#fff9c4 style H4 fill:#fff9c4 style H5 fill:#ffcdd2 API Integration Architecture graph TB subgraph \u0026#34;Client Layer\u0026#34; CL[Client Request] AUTH[Authentication] end subgraph \u0026#34;Pagoda Core\u0026#34; URLS[Django URLs] MW[Middleware] APIV2[API v2 Router] end subgraph \u0026#34;Plugin Layer\u0026#34; PU[Plugin URLs] PAM[Plugin API Mixin] PV[Plugin Views] PL[Plugin Logic] end subgraph \u0026#34;Model Access Layer\u0026#34; MI[Model Injection] SDK_MODELS[SDK Models] end subgraph \u0026#34;Pagoda Backend\u0026#34; MODELS[Django Models] PERMS[Permissions] HOOKS[Hook System] end CL --\u0026gt; AUTH AUTH --\u0026gt; MW MW --\u0026gt; URLS URLS --\u0026gt; APIV2 APIV2 --\u0026gt; PU PU --\u0026gt; PAM PAM --\u0026gt; PV PV --\u0026gt; PL PL --\u0026gt; SDK_MODELS SDK_MODELS --\u0026gt; MI MI --\u0026gt; MODELS PV --\u0026gt; PERMS PV --\u0026gt; HOOKS style CL fill:#ffebee style PL fill:#f3e5f5 style MI fill:#e8f5e8 style MODELS fill:#e3f2fd Plugin Development Lifecycle Development Phase Architecture graph TD subgraph \u0026#34;Development Environment\u0026#34; DEV[Developer Machine] PC[pagoda-plugin-sdk install] PE[Plugin Examples] IDE[IDE/Editor] end subgraph \u0026#34;Local Testing\u0026#34; LS[Local Server] PI[Plugin Install] IT[Integration Tests] UT[Unit Tests] end subgraph \u0026#34;Build \u0026amp; Package\u0026#34; BP[Build Process] PKG[Package Creation] TEST[Test Distribution] DOC[Documentation] end subgraph \u0026#34;Distribution\u0026#34; PYPI[PyPI Publication] GHR[GitHub Releases] PRIV[Private Registry] end DEV --\u0026gt; PC PC --\u0026gt; PE PE --\u0026gt; IDE IDE --\u0026gt; LS LS --\u0026gt; PI PI --\u0026gt; IT IT --\u0026gt; UT UT --\u0026gt; BP BP --\u0026gt; PKG PKG --\u0026gt; TEST TEST --\u0026gt; DOC DOC --\u0026gt; PYPI DOC --\u0026gt; GHR DOC --\u0026gt; PRIV style DEV fill:#e1f5fe style BP fill:#f3e5f5 style PYPI fill:#e8f5e8 Runtime Architecture graph LR subgraph \u0026#34;Production Environment\u0026#34; PROD[Production Server] ENV[Environment Variables] DEPS[Dependencies] end subgraph \u0026#34;Pagoda Instance\u0026#34; DJANGO[Django Application] SETTINGS[Settings Integration] INSTALLED[Installed Apps] end subgraph \u0026#34;Plugin Runtime\u0026#34; PREG[Plugin Registry] PINT[Plugin Integration] APIS[API Endpoints] HOOKS[Active Hooks] end subgraph \u0026#34;Monitoring\u0026#34; LOGS[Log Monitoring] PERF[Performance Metrics] ERRORS[Error Tracking] end PROD --\u0026gt; ENV ENV --\u0026gt; DJANGO DJANGO --\u0026gt; SETTINGS SETTINGS --\u0026gt; INSTALLED INSTALLED --\u0026gt; PREG PREG --\u0026gt; PINT PINT --\u0026gt; APIS PINT --\u0026gt; HOOKS APIS --\u0026gt; LOGS HOOKS --\u0026gt; LOGS LOGS --\u0026gt; PERF LOGS --\u0026gt; ERRORS style PROD fill:#ffebee style PREG fill:#f3e5f5 style LOGS fill:#e8f5e8 Data Flow Diagrams Plugin API Request Flow sequenceDiagram participant C as Client participant Pagoda as Pagoda Server participant PluginAPI as Plugin API View participant SDK_MODELS as SDK Models participant DB as Database C-\u0026gt;\u0026gt;Pagoda: GET /api/v2/plugins/my-plugin/entities/ Pagoda-\u0026gt;\u0026gt;Pagoda: Authentication check Pagoda-\u0026gt;\u0026gt;PluginAPI: Route to plugin endpoint PluginAPI-\u0026gt;\u0026gt;PluginAPI: Plugin logic execution PluginAPI-\u0026gt;\u0026gt;SDK_MODELS: Access Entity model SDK_MODELS-\u0026gt;\u0026gt;DB: Execute database query DB--\u0026gt;\u0026gt;SDK_MODELS: Return data SDK_MODELS--\u0026gt;\u0026gt;PluginAPI: Entity instances PluginAPI--\u0026gt;\u0026gt;Pagoda: API response Pagoda--\u0026gt;\u0026gt;C: JSON response Note over C,DB: Complete plugin API request flow with model access Plugin Hook Execution Flow sequenceDiagram participant User as User Action participant Pagoda as Pagoda Core participant Django as Django Signal participant HookBridge as Hook Bridge participant Plugin as Plugin Handler User-\u0026gt;\u0026gt;Pagoda: Create Entry Pagoda-\u0026gt;\u0026gt;Django: post_save signal Django-\u0026gt;\u0026gt;HookBridge: entry.after_create hook HookBridge-\u0026gt;\u0026gt;HookBridge: Find registered callbacks loop For each plugin callback HookBridge-\u0026gt;\u0026gt;Plugin: Execute plugin hook Plugin-\u0026gt;\u0026gt;Plugin: Custom logic Plugin--\u0026gt;\u0026gt;HookBridge: Return result end HookBridge--\u0026gt;\u0026gt;Django: All results Django--\u0026gt;\u0026gt;Pagoda: Hook execution complete Pagoda--\u0026gt;\u0026gt;User: Entry created successfully Note over User,Plugin: Plugin hook execution on entry creation Plugin Job Task Execution Flow sequenceDiagram participant API as Plugin API View participant Registry as PluginTaskRegistry participant Job as Job Model participant Celery as Celery Queue participant Worker as Celery Worker participant Task as Plugin Task Handler API-\u0026gt;\u0026gt;Registry: get_operation_id(\u0026#34;plugin-id\u0026#34;, \u0026#34;task_name\u0026#34;) Registry--\u0026gt;\u0026gt;API: operation_id (e.g., 5001) API-\u0026gt;\u0026gt;Job: _create_new_job(user, operation_id, params) Job-\u0026gt;\u0026gt;Job: Set status = PREPARING Job--\u0026gt;\u0026gt;API: Job instance API-\u0026gt;\u0026gt;Job: run() Job-\u0026gt;\u0026gt;Registry: get_task_handler(operation_id) Registry--\u0026gt;\u0026gt;Job: Task function reference Job-\u0026gt;\u0026gt;Celery: Queue task with job_id Job-\u0026gt;\u0026gt;Job: Set status = PROCESSING (queued) Job--\u0026gt;\u0026gt;API: Task queued Celery-\u0026gt;\u0026gt;Worker: Dispatch task to worker Worker-\u0026gt;\u0026gt;Task: Execute task(job_id) Task-\u0026gt;\u0026gt;Job: objects.get(id=job_id) Task-\u0026gt;\u0026gt;Task: Check is_canceled() Task-\u0026gt;\u0026gt;Task: Check proceed_if_ready() Task-\u0026gt;\u0026gt;Job: update(JobStatus.PROCESSING) alt Task Success Task-\u0026gt;\u0026gt;Task: Execute business logic Task-\u0026gt;\u0026gt;Job: update(JobStatus.DONE) else Task Failure Task-\u0026gt;\u0026gt;Task: Exception caught Task-\u0026gt;\u0026gt;Job: update(JobStatus.ERROR) end Note over API,Task: User can check job status via Job API\u0026lt;br/\u0026gt;GET /api/v2/jobs/{job_id}/ Plugin Operation ID Validation Flow graph TB subgraph \u0026#34;Django Startup\u0026#34; START[Django Initialization] JOB_APP[job/apps.py\u0026lt;br/\u0026gt;JobConfig.ready] end subgraph \u0026#34;PluginTaskRegistry.validate_all\u0026#34; LOAD_ENV[Load PLUGIN_OPERATION_ID_CONFIG\u0026lt;br/\u0026gt;from environment/settings] GET_PLUGINS[Get all registered plugins\u0026lt;br/\u0026gt;from _plugin_configs] CHECK_RANGES[Validate ID ranges\u0026lt;br/\u0026gt;for each plugin] CHECK_OFFSETS[Validate task offsets\u0026lt;br/\u0026gt;within ranges] CHECK_CONFLICTS[Check ID conflicts\u0026lt;br/\u0026gt;between plugins] BUILD_MAPS[Build operation_id mappings\u0026lt;br/\u0026gt;_operation_id_map] end subgraph \u0026#34;Validation Checks\u0026#34; RANGE_CHECK{Range valid?} OFFSET_CHECK{Offsets valid?} CONFLICT_CHECK{No conflicts?} end subgraph \u0026#34;Results\u0026#34; SUCCESS[Validation Success\u0026lt;br/\u0026gt;Django starts normally] FAIL_RANGE[ImproperlyConfigured\u0026lt;br/\u0026gt;Invalid range] FAIL_OFFSET[ImproperlyConfigured\u0026lt;br/\u0026gt;Offset exceeds range] FAIL_CONFLICT[ImproperlyConfigured\u0026lt;br/\u0026gt;ID conflict detected] ABORT[Django Startup Aborted] end START --\u0026gt; JOB_APP JOB_APP --\u0026gt; LOAD_ENV LOAD_ENV --\u0026gt; GET_PLUGINS GET_PLUGINS --\u0026gt; CHECK_RANGES CHECK_RANGES --\u0026gt; RANGE_CHECK RANGE_CHECK --\u0026gt;|Invalid| FAIL_RANGE RANGE_CHECK --\u0026gt;|Valid| CHECK_OFFSETS CHECK_OFFSETS --\u0026gt; OFFSET_CHECK OFFSET_CHECK --\u0026gt;|Exceeds| FAIL_OFFSET OFFSET_CHECK --\u0026gt;|Valid| CHECK_CONFLICTS CHECK_CONFLICTS --\u0026gt; CONFLICT_CHECK CONFLICT_CHECK --\u0026gt;|Conflict| FAIL_CONFLICT CONFLICT_CHECK --\u0026gt;|No conflict| BUILD_MAPS BUILD_MAPS --\u0026gt; SUCCESS FAIL_RANGE --\u0026gt; ABORT FAIL_OFFSET --\u0026gt; ABORT FAIL_CONFLICT --\u0026gt; ABORT style START fill:#e1f5fe style SUCCESS fill:#e8f5e8 style FAIL_RANGE fill:#ffebee style FAIL_OFFSET fill:#ffebee style FAIL_CONFLICT fill:#ffebee style ABORT fill:#ffcdd2 Job Model method_table Architecture graph LR subgraph \u0026#34;Static Task Registration\u0026#34; CORE[Core Tasks\u0026lt;br/\u0026gt;@register_job_task\u0026lt;br/\u0026gt;IDs: 1-99] CORE_DECORATOR[Decorator stores\u0026lt;br/\u0026gt;operation -\u0026gt; method\u0026lt;br/\u0026gt;in _METHOD_TABLE] end subgraph \u0026#34;Dynamic Task Registration\u0026#34; CUSTOM[custom_view Tasks\u0026lt;br/\u0026gt;CUSTOM_TASKS dict\u0026lt;br/\u0026gt;IDs: 100-199] PLUGIN[Plugin Tasks\u0026lt;br/\u0026gt;PluginTaskRegistry\u0026lt;br/\u0026gt;IDs: 200-9999] PLUGIN_CONFIG[Plugin config files\u0026lt;br/\u0026gt;PluginTaskConfig] end subgraph \u0026#34;method_table classmethod\u0026#34; BUILD[Build _METHOD_TABLE\u0026lt;br/\u0026gt;if not exists] MERGE_CUSTOM[Merge CUSTOM_TASKS] MERGE_PLUGIN[Get all tasks from\u0026lt;br/\u0026gt;PluginTaskRegistry] IMPORT[Dynamic import\u0026lt;br/\u0026gt;get_task_module] MAP[Map operation_id\u0026lt;br/\u0026gt;to task handler] end subgraph \u0026#34;Task Execution\u0026#34; JOB_RUN[job.run] LOOKUP[Lookup handler from\u0026lt;br/\u0026gt;method_table] GET_HANDLER[Get task handler\u0026lt;br/\u0026gt;by operation_id] EXECUTE[Execute task.delay\u0026lt;br/\u0026gt;with job_id] CELERY[Celery worker\u0026lt;br/\u0026gt;executes task] end CORE --\u0026gt; CORE_DECORATOR CORE_DECORATOR --\u0026gt; BUILD CUSTOM --\u0026gt; MERGE_CUSTOM PLUGIN_CONFIG --\u0026gt; PLUGIN PLUGIN --\u0026gt; MERGE_PLUGIN BUILD --\u0026gt; MERGE_CUSTOM MERGE_CUSTOM --\u0026gt; MERGE_PLUGIN MERGE_PLUGIN --\u0026gt; IMPORT IMPORT --\u0026gt; MAP MAP --\u0026gt; LOOKUP JOB_RUN --\u0026gt; GET_HANDLER GET_HANDLER --\u0026gt; LOOKUP LOOKUP --\u0026gt; EXECUTE EXECUTE --\u0026gt; CELERY style CORE fill:#e1f5fe style CUSTOM fill:#fff3e0 style PLUGIN fill:#f3e5f5 style BUILD fill:#e8f5e8 style CELERY fill:#e3f2fd Error Handling \u0026amp; Recovery Plugin Error Isolation graph TD subgraph \u0026#34;Error Sources\u0026#34; PE[Plugin Error] DE[Discovery Error] RE[Registration Error] HE[Hook Error] end subgraph \u0026#34;Error Handling\u0026#34; EH[Error Handler] LOG[Error Logging] ISO[Error Isolation] REC[Recovery Logic] end subgraph \u0026#34;System Response\u0026#34; CONT[Continue Operation] ALERT[Admin Alert] SKIP[Skip Plugin] FALLBACK[Fallback Mode] end PE --\u0026gt; EH DE --\u0026gt; EH RE --\u0026gt; EH HE --\u0026gt; EH EH --\u0026gt; LOG EH --\u0026gt; ISO EH --\u0026gt; REC LOG --\u0026gt; ALERT ISO --\u0026gt; SKIP ISO --\u0026gt; CONT REC --\u0026gt; FALLBACK style PE fill:#ffebee style EH fill:#fff3e0 style CONT fill:#e8f5e8 Plugin System Health Check graph LR subgraph \u0026#34;Health Monitoring\u0026#34; HC[Health Check] PS[Plugin Status] EP[Endpoint Status] HS[Hook Status] end subgraph \u0026#34;Metrics Collection\u0026#34; PM[Performance Metrics] EM[Error Metrics] UM[Usage Metrics] end subgraph \u0026#34;Alerting\u0026#34; TH[Thresholds] AL[Alerts] NOT[Notifications] end HC --\u0026gt; PS HC --\u0026gt; EP HC --\u0026gt; HS PS --\u0026gt; PM EP --\u0026gt; PM HS --\u0026gt; PM PM --\u0026gt; EM PM --\u0026gt; UM EM --\u0026gt; TH UM --\u0026gt; TH TH --\u0026gt; AL AL --\u0026gt; NOT style HC fill:#e1f5fe style PM fill:#f3e5f5 style AL fill:#ffebee Security Architecture Plugin Security Boundaries graph TB subgraph \u0026#34;Security Layers\u0026#34; AUTH[Authentication Layer] AUTHZ[Authorization Layer] VALID[Input Validation] SAND[Plugin Sandboxing] end subgraph \u0026#34;Plugin Constraints\u0026#34; API[API Limitations] PERM[Permission Checking] RATE[Rate Limiting] AUDIT[Audit Logging] end subgraph \u0026#34;Core Protection\u0026#34; ISOL[Core Isolation] INTER[Interface Controls] BRIDGE[Bridge Security] end AUTH --\u0026gt; API AUTHZ --\u0026gt; PERM VALID --\u0026gt; RATE SAND --\u0026gt; AUDIT API --\u0026gt; ISOL PERM --\u0026gt; INTER RATE --\u0026gt; BRIDGE AUDIT --\u0026gt; BRIDGE style AUTH fill:#ffebee style SAND fill:#fff3e0 style ISOL fill:#e8f5e8 Through this 3-layer architecture design with Protocol-based model injection, Pagoda provides a completely independent plugin ecosystem, realizing a secure and extensible platform. Plugin developers can provide unique value while accessing Pagoda\u0026rsquo;s core models through type-safe Protocol definitions, without creating implementation dependencies.
`}),e.add({id:1,href:"/advanced/plugin_entity_aware_routing/",title:"Entity-Aware Routing",parent:"Advanced Topics",content:`Overview Entity-Aware Routing enables entity-specific UI customization through the frontend plugin system. This feature allows administrators to configure custom plugin views for specific entities, replacing default Pagoda pages with plugin-provided alternatives.
Key Benefits Entity-Specific UX: Different entities can have completely different UI experiences Plugin-Based Customization: Leverage the plugin ecosystem for UI extensions Zero-Code Configuration: Switch views via Django settings, no code changes required Graceful Fallback: Missing plugins or pages automatically fall back to defaults Current Scope (Phase 1) Phase 1 supports:
Page Type: entry.list (Entity entries listing page) URL Pattern: /ui/entities/:entityId/entries Future phases may extend to additional page types such as entry.detail, entry.edit, etc.
Architecture System Overview graph TB subgraph \u0026#34;Django Backend\u0026#34; SETTINGS[settings_common.py\u0026lt;br/\u0026gt;ENTITY_PLUGIN_VIEWS] TEMPLATE[index.html Template] CONTEXT[django_context\u0026lt;br/\u0026gt;window.django_context] end subgraph \u0026#34;React Frontend\u0026#34; SERVERCTX[ServerContext] HOOK[usePluginMappings Hook] ROUTER[EntityAwareRoute] PLUGINMAP[pluginMap\u0026lt;br/\u0026gt;Map\u0026amp;lt;string, Plugin\u0026amp;gt;] end subgraph \u0026#34;Plugin Layer\u0026#34; PLUGIN[Entity View Plugin] PAGES[entityPages\u0026lt;br/\u0026gt;entry.list Component] end subgraph \u0026#34;UI Output\u0026#34; DEFAULT[Default EntryListPage] CUSTOM[Plugin Custom Page] end SETTINGS --\u0026gt; TEMPLATE TEMPLATE --\u0026gt; CONTEXT CONTEXT --\u0026gt; SERVERCTX SERVERCTX --\u0026gt; HOOK HOOK --\u0026gt; ROUTER PLUGINMAP --\u0026gt; ROUTER PLUGIN --\u0026gt; PAGES PAGES --\u0026gt; ROUTER ROUTER --\u0026gt;|No mapping| DEFAULT ROUTER --\u0026gt;|Has mapping| CUSTOM style SETTINGS fill:#e8f5e8 style ROUTER fill:#e1f5fe style PLUGIN fill:#f3e5f5 Data Flow sequenceDiagram participant Admin as Administrator participant Django as Django Settings participant Template as HTML Template participant React as React App participant Router as EntityAwareRoute participant Plugin as Plugin Component Note over Admin,Django: Configuration Phase Admin-\u0026gt;\u0026gt;Django: Set ENTITY_PLUGIN_VIEWS\u0026lt;br/\u0026gt;{\u0026#34;9681\u0026#34;: {\u0026#34;plugin\u0026#34;: \u0026#34;sample\u0026#34;, \u0026#34;pages\u0026#34;: [\u0026#34;entry.list\u0026#34;]}} Note over Template,React: Page Load Phase Django-\u0026gt;\u0026gt;Template: Render index.html Template-\u0026gt;\u0026gt;React: window.django_context.entityPluginViews Note over React,Plugin: Routing Phase React-\u0026gt;\u0026gt;Router: Navigate to /ui/entities/9681/entries Router-\u0026gt;\u0026gt;Router: Extract entityId from URL Router-\u0026gt;\u0026gt;Router: Lookup config[entityId] (O(1)) Router-\u0026gt;\u0026gt;Router: Check if \u0026#34;entry.list\u0026#34; in pages Router-\u0026gt;\u0026gt;Router: Lookup pluginMap.get(\u0026#34;sample\u0026#34;) (O(1)) Router-\u0026gt;\u0026gt;Plugin: Render plugin.entityPages[\u0026#34;entry.list\u0026#34;] Plugin--\u0026gt;\u0026gt;React: Custom Entry List UI Component Relationships graph LR subgraph \u0026#34;App Initialization\u0026#34; APP[AppBase] PLUGINS[plugins: Plugin[]] MAP[pluginMap: Map] end subgraph \u0026#34;Routing Layer\u0026#34; APPROUTER[AppRouter] ROUTE[EntityAwareRoute] end subgraph \u0026#34;Data Sources\u0026#34; CTX[ServerContext] HOOK[usePluginMappings] CONFIG[EntityPluginViewsConfig] end subgraph \u0026#34;Resolution\u0026#34; LOOKUP_ID[config\u0026amp;lsqb;entityId\u0026amp;rsqb;] LOOKUP_PLUGIN[pluginMap.get\u0026amp;lpar;pluginId\u0026amp;rpar;] COMPONENT[PluginComponent] end APP --\u0026gt; PLUGINS PLUGINS --\u0026gt;|useMemo| MAP APP --\u0026gt; APPROUTER APPROUTER --\u0026gt; ROUTE MAP --\u0026gt; ROUTE CTX --\u0026gt; HOOK HOOK --\u0026gt; CONFIG CONFIG --\u0026gt; ROUTE ROUTE --\u0026gt; LOOKUP_ID LOOKUP_ID --\u0026gt; LOOKUP_PLUGIN LOOKUP_PLUGIN --\u0026gt; COMPONENT style APP fill:#e1f5fe style ROUTE fill:#f3e5f5 style COMPONENT fill:#e8f5e8 Configuration Django Settings Configure entity-plugin mappings in settings_common.py or via environment variable:
# airone/settings_common.py AIRONE = { # ... other settings ... # Entity-specific plugin view routing configuration # Format: { \u0026#34;entityId\u0026#34;: { \u0026#34;plugin\u0026#34;: \u0026#34;plugin-id\u0026#34;, \u0026#34;pages\u0026#34;: [\u0026#34;entry.list\u0026#34;] } } \u0026#34;ENTITY_PLUGIN_VIEWS\u0026#34;: json.loads( env.str( \u0026#34;ENTITY_PLUGIN_VIEWS\u0026#34;, json.dumps({}), # Default: no overrides ) ), } Configuration Format { \u0026#34;entityId\u0026#34;: { \u0026#34;plugin\u0026#34;: \u0026#34;plugin-id\u0026#34;, \u0026#34;pages\u0026#34;: [\u0026#34;entry.list\u0026#34;] } } Field Type Description entityId string The entity ID (as string) to apply custom routing plugin string The plugin ID that provides the custom view pages string[] List of page types to override (currently only \u0026quot;entry.list\u0026quot;) Example Configurations Single Entity Override:
export ENTITY_PLUGIN_VIEWS=\u0026#39;{\u0026#34;42\u0026#34;: {\u0026#34;plugin\u0026#34;: \u0026#34;network-tools\u0026#34;, \u0026#34;pages\u0026#34;: [\u0026#34;entry.list\u0026#34;]}}\u0026#39; Multiple Entity Overrides:
export ENTITY_PLUGIN_VIEWS=\u0026#39;{ \u0026#34;42\u0026#34;: {\u0026#34;plugin\u0026#34;: \u0026#34;network-tools\u0026#34;, \u0026#34;pages\u0026#34;: [\u0026#34;entry.list\u0026#34;]}, \u0026#34;100\u0026#34;: {\u0026#34;plugin\u0026#34;: \u0026#34;asset-manager\u0026#34;, \u0026#34;pages\u0026#34;: [\u0026#34;entry.list\u0026#34;]}, \u0026#34;255\u0026#34;: {\u0026#34;plugin\u0026#34;: \u0026#34;custom-dashboard\u0026#34;, \u0026#34;pages\u0026#34;: [\u0026#34;entry.list\u0026#34;]} }\u0026#39; Disable All Overrides:
export ENTITY_PLUGIN_VIEWS=\u0026#39;{}\u0026#39; Plugin Development Creating an Entity View Plugin To provide custom entity pages, your plugin must implement the EntityViewPlugin interface:
import { FC } from \u0026#34;react\u0026#34;; // Plugin interface for entity-specific views interface EntityViewPlugin { id: string; name: string; // Entity page components by page type entityPages?: { \u0026#34;entry.list\u0026#34;?: FC; // Future: \u0026#34;entry.detail\u0026#34;?, \u0026#34;entry.edit\u0026#34;?, etc. }; } Example Plugin Implementation // plugin-sample/src/index.ts import { FC } from \u0026#34;react\u0026#34;; import { CustomEntryList } from \u0026#34;./components/CustomEntryList\u0026#34;; interface Plugin { id: string; name: string; entityPages?: { \u0026#34;entry.list\u0026#34;?: FC; }; } const plugin: Plugin = { id: \u0026#34;sample\u0026#34;, name: \u0026#34;Sample Entity View Plugin\u0026#34;, entityPages: { \u0026#34;entry.list\u0026#34;: CustomEntryList, }, }; export default plugin; Custom Component Example // plugin-sample/src/components/CustomEntryList.tsx import { FC } from \u0026#34;react\u0026#34;; import { useParams } from \u0026#34;react-router\u0026#34;; import { Box, Typography } from \u0026#34;@mui/material\u0026#34;; export const CustomEntryList: FC = () =\u0026gt; { const { entityId } = useParams\u0026lt;{ entityId: string }\u0026gt;(); return ( \u0026lt;Box p={3}\u0026gt; \u0026lt;Typography variant=\u0026#34;h4\u0026#34;\u0026gt; Custom Entry List for Entity {entityId} \u0026lt;/Typography\u0026gt; {/* Your custom implementation */} \u0026lt;/Box\u0026gt; ); }; Plugin Registration Register your plugin in pagoda-minimal-builder:
// frontend/plugins/pagoda-minimal-builder/plugins.config.js module.exports = { plugins: [ \u0026#34;pagoda-plugin-hello-world\u0026#34;, \u0026#34;pagoda-plugin-dashboard\u0026#34;, \u0026#34;pagoda-plugin-entity-sample\u0026#34;, // Your entity view plugin ], }; Routing Flow Decision Logic flowchart TD START[User navigates to\u0026lt;br/\u0026gt;/ui/entities/:entityId/entries] CHECK_ID{entityId\u0026lt;br/\u0026gt;in URL?} LOOKUP_CONFIG[Lookup config\u0026amp;lsqb;entityId\u0026amp;rsqb;\u0026lt;br/\u0026gt;O\u0026amp;lpar;1\u0026amp;rpar;] CHECK_MAPPING{Mapping\u0026lt;br/\u0026gt;exists?} CHECK_PAGE{pageType in\u0026lt;br/\u0026gt;mapping.pages?} LOOKUP_PLUGIN[Lookup pluginMap.get\u0026amp;lpar;pluginId\u0026amp;rpar;\u0026lt;br/\u0026gt;O\u0026amp;lpar;1\u0026amp;rpar;] CHECK_PLUGIN{Plugin\u0026lt;br/\u0026gt;found?} CHECK_ENTITY_VIEW{Plugin has\u0026lt;br/\u0026gt;entityPages?} CHECK_COMPONENT{Page component\u0026lt;br/\u0026gt;exists?} RENDER_PLUGIN[Render Plugin Component] RENDER_DEFAULT[Render Default EntryListPage] START --\u0026gt; CHECK_ID CHECK_ID --\u0026gt;|No| RENDER_DEFAULT CHECK_ID --\u0026gt;|Yes| LOOKUP_CONFIG LOOKUP_CONFIG --\u0026gt; CHECK_MAPPING CHECK_MAPPING --\u0026gt;|No| RENDER_DEFAULT CHECK_MAPPING --\u0026gt;|Yes| CHECK_PAGE CHECK_PAGE --\u0026gt;|No| RENDER_DEFAULT CHECK_PAGE --\u0026gt;|Yes| LOOKUP_PLUGIN LOOKUP_PLUGIN --\u0026gt; CHECK_PLUGIN CHECK_PLUGIN --\u0026gt;|No| RENDER_DEFAULT CHECK_PLUGIN --\u0026gt;|Yes| CHECK_ENTITY_VIEW CHECK_ENTITY_VIEW --\u0026gt;|No| RENDER_DEFAULT CHECK_ENTITY_VIEW --\u0026gt;|Yes| CHECK_COMPONENT CHECK_COMPONENT --\u0026gt;|No| RENDER_DEFAULT CHECK_COMPONENT --\u0026gt;|Yes| RENDER_PLUGIN style START fill:#e1f5fe style RENDER_PLUGIN fill:#e8f5e8 style RENDER_DEFAULT fill:#fff3e0 Performance Characteristics All lookups are O(1):
Operation Complexity Implementation Entity mapping lookup O(1) config[entityId] object property access Plugin lookup O(1) pluginMap.get(pluginId) Map lookup Page check O(n) pages.includes(pageType) where n is typically 1-3 Total routing decision: O(1) with respect to number of entities and plugins.
Implementation Details Key Files File Purpose airone/settings_common.py Django configuration for ENTITY_PLUGIN_VIEWS templates/frontend/index.html Passes config to frontend via django_context frontend/src/plugins/index.ts Type definitions for EntityViewPlugin frontend/src/services/ServerContext.ts Reads entityPluginViews from window frontend/src/hooks/usePluginMappings.ts Hook to access plugin mappings frontend/src/routes/EntityAwareRoute.tsx Core routing logic component frontend/src/routes/AppRouter.tsx Integrates EntityAwareRoute frontend/src/AppBase.tsx Creates pluginMap from plugins array Type Definitions // frontend/src/plugins/index.ts // Supported page types for entity views export type EntityPageType = \u0026#34;entry.list\u0026#34;; // Configuration for a single entity mapping export interface EntityPluginMapping { plugin: string; // Plugin ID pages: EntityPageType[]; // Page types to override } // Full configuration: entityId -\u0026gt; mapping export type EntityPluginViewsConfig = Record\u0026lt;string, EntityPluginMapping\u0026gt;; // Plugin interface with entity pages export interface EntityViewPlugin extends Plugin { entityPages?: Partial\u0026lt;Record\u0026lt;EntityPageType, FC\u0026gt;\u0026gt;; } // Type guard function export function isEntityViewPlugin(plugin: Plugin): plugin is EntityViewPlugin { return \u0026#34;entityPages\u0026#34; in plugin \u0026amp;\u0026amp; plugin.entityPages !== undefined; } Verification Testing the Configuration Set up the configuration:
# In your Django settings or environment export ENTITY_PLUGIN_VIEWS=\u0026#39;{\u0026#34;9681\u0026#34;: {\u0026#34;plugin\u0026#34;: \u0026#34;sample\u0026#34;, \u0026#34;pages\u0026#34;: [\u0026#34;entry.list\u0026#34;]}}\u0026#39; Build the frontend with plugins:
# Build the core library npm run build:lib # Build with plugins cd frontend/plugins/pagoda-minimal-builder npm run build cp dist/ui.js ../../../static/js/ui.js Start the server:
python manage.py runserver Verify in browser:
Navigate to /ui/entities/9681/entries You should see the plugin\u0026rsquo;s custom view instead of the default EntryListPage Check console for configuration:
// In browser console console.log(window.django_context.entityPluginViews); // Output: {\u0026#34;9681\u0026#34;: {\u0026#34;plugin\u0026#34;: \u0026#34;sample\u0026#34;, \u0026#34;pages\u0026#34;: [\u0026#34;entry.list\u0026#34;]}} Debugging If the custom view is not displayed:
Check configuration is loaded:
window.django_context.entityPluginViews Verify plugin is registered:
Check pagoda-minimal-builder/plugins.config.js Ensure plugin is in the configured plugins list Check console warnings:
EntityAwareRoute logs warnings for: Plugin not found Plugin doesn\u0026rsquo;t support entity pages Page type not provided by plugin Future Extensions Planned Page Types Page Type URL Pattern Status entry.list /ui/entities/:entityId/entries Implemented entry.detail /ui/entities/:entityId/entries/:entryId Planned entry.edit /ui/entities/:entityId/entries/:entryId/edit Planned entry.create /ui/entities/:entityId/entries/new Planned Adding New Page Types To extend the system with new page types:
Add the page type to EntityPageType:
export type EntityPageType = \u0026#34;entry.list\u0026#34; | \u0026#34;entry.detail\u0026#34; | \u0026#34;entry.edit\u0026#34;; Add routing in AppRouter.tsx:
\u0026lt;Route path={entryDetailsPath(\u0026#34;:entityId\u0026#34;, \u0026#34;:entryId\u0026#34;)} element={ \u0026lt;EntityAwareRoute pageType=\u0026#34;entry.detail\u0026#34; defaultComponent={EntryDetailsPage} pluginMap={pluginMap} /\u0026gt; } /\u0026gt; Implement the page in your plugin:
entityPages: { \u0026#34;entry.list\u0026#34;: CustomEntryList, \u0026#34;entry.detail\u0026#34;: CustomEntryDetail, }, `}),e.add({id:2,href:"/advanced/plugin_quickstart_guide/",title:"Plugin Development Quick Start Guide",parent:"Advanced Topics",content:`Plugin Development in 5 Minutes This guide provides the shortest steps to create and verify your first plugin using the Pagoda plugin system.
Step 1: Environment Setup (2 minutes) 1.1 Install pagoda-plugin-sdk Install the plugin SDK from the Git repository:
Option A: From Git repository (recommended)
# Using pip pip install git+https://github.com/dmm-com/pagoda.git#subdirectory=plugin/sdk # Or using uv (faster) uv pip install git+https://github.com/dmm-com/pagoda.git#subdirectory=plugin/sdk # Verify installation python -c \u0026#34;import pagoda_plugin_sdk; print(\u0026#39;✓ pagoda-plugin-sdk ready\u0026#39;)\u0026#34; Option B: From local source (for SDK development)
cd /path/to/pagoda/plugin/sdk pip install -e . # Or using uv uv pip install -e . # Verify installation python -c \u0026#34;import pagoda_plugin_sdk; print(\u0026#39;✓ pagoda-plugin-sdk ready\u0026#39;)\u0026#34; 1.2 Install and Test Sample Plugin Install the hello-world sample plugin to verify your environment:
# Navigate to sample plugin directory cd ../examples/pagoda-hello-world-plugin # Install sample plugin (choose one) pip install -e . # Using pip # OR uv pip install -e . # Using uv # Verify plugin installation python -c \u0026#34;from pagoda_hello_world_plugin.plugin import HelloWorldPlugin; print(\u0026#39;✓ Sample plugin ready\u0026#39;)\u0026#34; 1.3 Test Plugin with Pagoda Start the Pagoda server with the sample plugin enabled:
# Navigate back to Pagoda root cd ../../.. # Start server with plugin enabled ENABLED_PLUGINS=hello-world python manage.py runserver 8080 # In another terminal, test the plugin endpoint curl http://localhost:8080/api/v2/plugins/hello-world-plugin/test/ Expected Response:
{ \u0026#34;message\u0026#34;: \u0026#34;External Hello World Plugin is working via pagoda-plugin-sdk!\u0026#34;, \u0026#34;plugin\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;hello-world-plugin\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Hello World Plugin\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;external\u0026#34;, \u0026#34;core\u0026#34;: \u0026#34;pagoda-plugin-sdk\u0026#34; }, \u0026#34;test\u0026#34;: \u0026#34;no-auth\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;anonymous\u0026#34;, \u0026#34;is_authenticated\u0026#34;: false } } ✅ If everything works correctly up to this point, environment setup is complete!
Common Issues:
If ENABLED_PLUGINS is not set, plugins won\u0026rsquo;t be loaded Plugin entry point name must match: hello-world in environment variable maps to entry point in pyproject.toml Both SDK and plugin must be installed in the same Python environment Step 2: Creating Your First Plugin (3 minutes) 2.1 Create Plugin Project Structure Create a new directory for your plugin outside the Pagoda repository:
# Create plugin project directory mkdir my-first-plugin cd my-first-plugin # Create package directory structure mkdir -p my_first_plugin/api_v2 touch my_first_plugin/__init__.py touch my_first_plugin/plugin.py touch my_first_plugin/apps.py touch my_first_plugin/api_v2/__init__.py touch my_first_plugin/api_v2/urls.py touch my_first_plugin/api_v2/views.py touch README.md Your plugin structure should look like:
my-first-plugin/ ├── README.md ├── pyproject.toml (create in next step) └── my_first_plugin/ ├── __init__.py ├── plugin.py ├── apps.py └── api_v2/ ├── __init__.py ├── urls.py └── views.py 2.2 Configure pyproject.toml Create pyproject.toml with the following content:
[project] name = \u0026#34;my-first-plugin\u0026#34; version = \u0026#34;1.0.0\u0026#34; description = \u0026#34;My First Pagoda Plugin\u0026#34; readme = \u0026#34;README.md\u0026#34; license = {text = \u0026#34;MIT\u0026#34;} authors = [ {name = \u0026#34;Your Name\u0026#34;, email = \u0026#34;you@example.com\u0026#34;} ] dependencies = [ \u0026#34;pagoda-plugin-sdk @ git+https://github.com/dmm-com/pagoda.git#subdirectory=plugin/sdk\u0026#34;, \u0026#34;Django\u0026gt;=3.2\u0026#34;, \u0026#34;djangorestframework\u0026gt;=3.12\u0026#34;, ] requires-python = \u0026#34;\u0026gt;=3.8\u0026#34; [project.entry-points.\u0026#34;pagoda.plugins\u0026#34;] my-first = \u0026#34;my_first_plugin.plugin:MyFirstPlugin\u0026#34; [build-system] requires = [\u0026#34;hatchling\u0026#34;] build-backend = \u0026#34;hatchling.build\u0026#34; [tool.hatch.build.targets.wheel] packages = [\u0026#34;my_first_plugin\u0026#34;] Important Notes:
Entry point name (my-first) is what you\u0026rsquo;ll use in ENABLED_PLUGINS Entry point value must point to your plugin class: package.module:ClassName Build backend is hatchling (modern, fast Python packager) 2.3 Customize Plugin Class # my_first_plugin/plugin.py from pagoda_plugin_sdk import Plugin from pagoda_plugin_sdk.decorators import ( entry_hook, entity_hook, validation_hook, get_attrs_hook ) import logging logger = logging.getLogger(__name__) class MyFirstPlugin(Plugin): id = \u0026#34;my-first-plugin\u0026#34; name = \u0026#34;My First Plugin\u0026#34; version = \u0026#34;1.0.0\u0026#34; description = \u0026#34;My very first Pagoda plugin\u0026#34; author = \u0026#34;Your Name\u0026#34; django_apps = [\u0026#34;my_first_plugin\u0026#34;] api_v2_patterns = \u0026#34;my_first_plugin.api_v2.urls\u0026#34; # Entry Lifecycle Hooks @entry_hook(\u0026#34;after_create\u0026#34;) def log_entry_create(self, entity_name, user, entry, **kwargs): \u0026#34;\u0026#34;\u0026#34;Hook executed after Entry creation (all entities)\u0026#34;\u0026#34;\u0026#34; logger.info(f\u0026#34;New entry created: {entry.name} in entity {entity_name} by {user.username}\u0026#34;) print(f\u0026#34;My First Plugin detected new entry: {entry.name}\u0026#34;) @entry_hook(\u0026#34;after_create\u0026#34;, entity=\u0026#34;customer\u0026#34;, priority=50) def log_customer_create(self, entity_name, user, entry, **kwargs): \u0026#34;\u0026#34;\u0026#34;Hook executed only for \u0026#39;customer\u0026#39; entity with high priority\u0026#34;\u0026#34;\u0026#34; logger.info(f\u0026#34;Customer entry created: {entry.name}\u0026#34;) # Perform customer-specific processing @entry_hook(\u0026#34;before_update\u0026#34;) def modify_entry_before_update(self, entity_name, user, validated_data, entry, **kwargs): \u0026#34;\u0026#34;\u0026#34;Hook executed before Entry update - can modify data\u0026#34;\u0026#34;\u0026#34; logger.info(f\u0026#34;Entry updating: {entry.name}\u0026#34;) # You can modify validated_data before update # validated_data[\u0026#34;name\u0026#34;] = validated_data[\u0026#34;name\u0026#34;].upper() return validated_data # Entity Lifecycle Hooks @entity_hook(\u0026#34;after_create\u0026#34;) def log_entity_create(self, user, entity, **kwargs): \u0026#34;\u0026#34;\u0026#34;Hook executed after Entity creation\u0026#34;\u0026#34;\u0026#34; logger.info(f\u0026#34;New entity created: {entity.name} by {user.username}\u0026#34;) @entity_hook(\u0026#34;before_update\u0026#34;) def modify_entity_before_update(self, user, validated_data, entity, **kwargs): \u0026#34;\u0026#34;\u0026#34;Hook executed before Entity update - can modify data\u0026#34;\u0026#34;\u0026#34; logger.info(f\u0026#34;Entity updating: {entity.name}\u0026#34;) return validated_data # Validation Hook @validation_hook() def validate_entry_name(self, user, schema_name, name, attrs, instance, **kwargs): \u0026#34;\u0026#34;\u0026#34;Custom validation for entry creation/update Raises ValueError to reject invalid entries \u0026#34;\u0026#34;\u0026#34; # Example: Reject entries with forbidden words forbidden_words = [\u0026#34;forbidden\u0026#34;, \u0026#34;banned\u0026#34;, \u0026#34;illegal\u0026#34;] if any(word in name.lower() for word in forbidden_words): raise ValueError(f\u0026#34;Entry name cannot contain forbidden words\u0026#34;) # Example: Validate minimum name length if len(name) \u0026lt; 3: raise ValueError(\u0026#34;Entry name must be at least 3 characters\u0026#34;) # Data Access Hooks @get_attrs_hook(\u0026#34;entry\u0026#34;) def add_custom_entry_metadata(self, entry, attrinfo, is_retrieve, **kwargs): \u0026#34;\u0026#34;\u0026#34;Add custom metadata to entry attributes\u0026#34;\u0026#34;\u0026#34; logger.info(f\u0026#34;Getting entry attrs for: {entry.name}\u0026#34;) # Add custom metadata to each attribute for attr in attrinfo: attr[\u0026#34;plugin_processed\u0026#34;] = True attr[\u0026#34;processed_by\u0026#34;] = \u0026#34;my-first-plugin\u0026#34; return attrinfo @get_attrs_hook(\u0026#34;entity\u0026#34;) def add_custom_entity_metadata(self, entity, attrinfo, **kwargs): \u0026#34;\u0026#34;\u0026#34;Add custom metadata to entity attributes\u0026#34;\u0026#34;\u0026#34; logger.info(f\u0026#34;Getting entity attrs for: {entity.name}\u0026#34;) # Add plugin-specific information for attr in attrinfo: attr[\u0026#34;plugin_version\u0026#34;] = self.version return attrinfo Decorator Types and Usage:
@entry_hook(hook_name, entity=None, priority=100)
For Entry lifecycle events Supports entity-specific filtering Can modify data in \u0026ldquo;before\u0026rdquo; hooks @entity_hook(hook_name, priority=100)
For Entity lifecycle events Can modify data in \u0026ldquo;before\u0026rdquo; hooks @validation_hook(priority=100)
For entry validation Raise ValueError to reject invalid data @get_attrs_hook(target, priority=100)
For modifying data before returning to client Target must be \u0026ldquo;entry\u0026rdquo; or \u0026ldquo;entity\u0026rdquo; Must return modified attrinfo list 2.4 Customize API Endpoints # my_first_plugin/api_v2/views.py from datetime import datetime from rest_framework.response import Response from rest_framework.permissions import AllowAny from pagoda_plugin_sdk import PluginAPIViewMixin class MyFirstView(PluginAPIViewMixin): permission_classes = [AllowAny] def get(self, request): return Response({ \u0026#34;message\u0026#34;: \u0026#34;Hello from My First Plugin!\u0026#34;, \u0026#34;plugin\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;my-first-plugin\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;My First Plugin\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34; }, \u0026#34;custom_data\u0026#34;: { \u0026#34;greeting\u0026#34;: \u0026#34;Welcome to plugin development!\u0026#34;, \u0026#34;tips\u0026#34;: \u0026#34;Check the documentation for advanced features\u0026#34; }, \u0026#34;timestamp\u0026#34;: datetime.now().isoformat() }) # my_first_plugin/api_v2/urls.py from django.urls import path from . import views urlpatterns = [ path(\u0026#34;test/\u0026#34;, views.MyFirstView.as_view(), name=\u0026#34;test\u0026#34;), path(\u0026#34;hello/\u0026#34;, views.MyFirstView.as_view(), name=\u0026#34;hello\u0026#34;), ] 2.5 Add Asynchronous Job Tasks (Optional) If your plugin needs to run long-running operations (e.g., data export, batch processing, external API calls), you can define Celery job tasks that integrate with Airone\u0026rsquo;s Job system.
Step 1: Create config.py with operation definitions
# my_first_plugin/config.py import enum from airone.lib.plugin_task import PluginTaskConfig class MyFirstPluginOperation(int, enum.Enum): \u0026#34;\u0026#34;\u0026#34;Operation offsets for job tasks\u0026#34;\u0026#34;\u0026#34; PROCESS_DATA = 0 # offset within allocated range PLUGIN_TASK_CONFIG = PluginTaskConfig( plugin_id=\u0026#34;my-first-plugin\u0026#34;, module_path=\u0026#34;my_first_plugin.tasks\u0026#34;, tasks={ \u0026#34;process_data\u0026#34;: (MyFirstPluginOperation.PROCESS_DATA, \u0026#34;process_data\u0026#34;), }, # Optional: specify task behavior cancelable_operations=[\u0026#34;process_data\u0026#34;], # Allow user cancellation ) Step 2: Create tasks.py with task implementation
# my_first_plugin/tasks.py import logging import time from airone.celery import app from airone.lib.plugin_task import register_plugin_job_task from job.models import Job, JobStatus from my_first_plugin.config import MyFirstPluginOperation logger = logging.getLogger(__name__) @register_plugin_job_task(MyFirstPluginOperation.PROCESS_DATA) @app.task(bind=True) def process_data(self, job_id: int): \u0026#34;\u0026#34;\u0026#34;Example background job task\u0026#34;\u0026#34;\u0026#34; try: job = Job.objects.get(id=job_id) except Job.DoesNotExist: logger.error(f\u0026#34;Job {job_id} not found\u0026#34;) return # Check if job was canceled by user if job.is_canceled(): logger.info(f\u0026#34;Job {job_id} was canceled\u0026#34;) return # Check if job is ready to proceed if not job.proceed_if_ready(): logger.warning(f\u0026#34;Job {job_id} is not ready\u0026#34;) return # Update status to processing job.update(JobStatus.PROCESSING) try: # Get job parameters params = job.params input_data = params.get(\u0026#34;input\u0026#34;) logger.info(f\u0026#34;Processing job {job_id} with input: {input_data}\u0026#34;) # Example: Simulate long-running operation time.sleep(5) # Update status to done job.update(JobStatus.DONE) logger.info(f\u0026#34;Job {job_id} completed successfully\u0026#34;) except Exception as e: logger.error(f\u0026#34;Job {job_id} failed: {e}\u0026#34;, exc_info=True) job.update(JobStatus.ERROR) Step 3: Register tasks in apps.py
Update your apps.py to register the task configuration:
# my_first_plugin/apps.py import logging from django.apps import AppConfig from airone.lib.plugin_task import PluginTaskRegistry logger = logging.getLogger(__name__) class MyFirstPluginConfig(AppConfig): default_auto_field = \u0026#34;django.db.models.BigAutoField\u0026#34; name = \u0026#34;my_first_plugin\u0026#34; def ready(self): \u0026#34;\u0026#34;\u0026#34;Called when Django app is ready\u0026#34;\u0026#34;\u0026#34; from my_first_plugin.config import PLUGIN_TASK_CONFIG # Register plugin tasks PluginTaskRegistry.register(PLUGIN_TASK_CONFIG) logger.info(\u0026#34;Plugin tasks registered successfully\u0026#34;) Step 4: Create API endpoint to trigger job
Add a new view to trigger the background job:
# my_first_plugin/api_v2/views.py (add this class) from rest_framework.response import Response from rest_framework import status from pagoda_plugin_sdk import PluginAPIViewMixin from airone.lib.plugin_task import PluginTaskRegistry from job.models import Job class ProcessDataView(PluginAPIViewMixin): def post(self, request): \u0026#34;\u0026#34;\u0026#34;Trigger background data processing job\u0026#34;\u0026#34;\u0026#34; try: # Get operation_id from registry operation_id = PluginTaskRegistry.get_operation_id( \u0026#34;my-first-plugin\u0026#34;, \u0026#34;process_data\u0026#34; ) # Create new job job = Job._create_new_job( user=request.user, target=None, operation=operation_id, text=\u0026#34;Processing data\u0026#34;, params={ \u0026#34;input\u0026#34;: request.data.get(\u0026#34;input\u0026#34;), }, ) # Queue job for execution job.run() return Response({ \u0026#34;message\u0026#34;: \u0026#34;Task queued successfully\u0026#34;, \u0026#34;job_id\u0026#34;: job.id, }, status=status.HTTP_201_CREATED) except Exception as e: return Response( {\u0026#34;error\u0026#34;: str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR ) Update urls.py to add the new endpoint:
# my_first_plugin/api_v2/urls.py from django.urls import path from . import views urlpatterns = [ path(\u0026#34;test/\u0026#34;, views.MyFirstView.as_view(), name=\u0026#34;test\u0026#34;), path(\u0026#34;hello/\u0026#34;, views.MyFirstView.as_view(), name=\u0026#34;hello\u0026#34;), path(\u0026#34;process/\u0026#34;, views.ProcessDataView.as_view(), name=\u0026#34;process\u0026#34;), # New ] Step 5: Configure operation_id range in settings
In Airone\u0026rsquo;s settings, allocate an operation_id range for your plugin:
# In airone/settings_common.py or set as environment variable PLUGIN_OPERATION_ID_CONFIG = { \u0026#34;my-first-plugin\u0026#34;: (6000, 6099), # Allocate 100 operation IDs } Or set via environment variable:
export PLUGIN_OPERATION_ID_CONFIG=\u0026#39;{\u0026#34;my-first-plugin\u0026#34;: [6000, 6099]}\u0026#39; Step 6: Test with Celery worker
To test job tasks, you need to run both a Celery worker and the Django server:
# Terminal 1: Start Celery worker poetry run celery -A airone worker -l info # Terminal 2: Start Django server ENABLED_PLUGINS=my-first python manage.py runserver # Terminal 3: Test the job endpoint curl -X POST http://localhost:8080/api/v2/plugins/my-first/process/ \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -H \u0026#34;Authorization: Token YOUR_TOKEN\u0026#34; \\ -d \u0026#39;{\u0026#34;input\u0026#34;: \u0026#34;test data\u0026#34;}\u0026#39; Expected Response:
{ \u0026#34;message\u0026#34;: \u0026#34;Task queued successfully\u0026#34;, \u0026#34;job_id\u0026#34;: 123 } Check job status:
curl http://localhost:8080/api/v2/jobs/123/ \\ -H \u0026#34;Authorization: Token YOUR_TOKEN\u0026#34; Response:
{ \u0026#34;id\u0026#34;: 123, \u0026#34;user\u0026#34;: {\u0026#34;id\u0026#34;: 1, \u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;}, \u0026#34;text\u0026#34;: \u0026#34;Processing data\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;DONE\u0026#34;, \u0026#34;operation\u0026#34;: 6000, \u0026#34;created_at\u0026#34;: \u0026#34;2025-11-01T12:00:00Z\u0026#34;, \u0026#34;updated_at\u0026#34;: \u0026#34;2025-11-01T12:00:05Z\u0026#34; } Troubleshooting Job Tasks:
Issue Cause Solution Task not executing Celery worker not running Start Celery worker: poetry run celery -A airone worker -l info Operation ID error Range not configured Add plugin to PLUGIN_OPERATION_ID_CONFIG Import error Registry not called Ensure PluginTaskRegistry.register() is in apps.py ready() Job status stuck at PREPARING Task handler not found Check decorator @register_plugin_job_task(offset) is present Job Task Best Practices:
Always check job status: Use job.is_canceled() and job.proceed_if_ready() Update status appropriately: PROCESSING when starting, DONE/ERROR when finished Handle errors gracefully: Catch exceptions and update to ERROR status Use meaningful job text: Help users understand what the job is doing Test with Celery: Always test with a running Celery worker For more details on job tasks, see the Plugin System Documentation.
Step 3: Plugin Testing \u0026amp; Installation 3.1 Install Your Plugin in Development Mode Navigate to your plugin directory and install it:
Option A: Using pip
cd /path/to/my-first-plugin pip install -e . Option B: Using uv (recommended)
cd /path/to/my-first-plugin uv pip install -e . 3.2 Verify Plugin Installation Check that your plugin can be imported and instantiated:
python -c \u0026#34; from my_first_plugin.plugin import MyFirstPlugin plugin = MyFirstPlugin() print(f\u0026#39;✓ Plugin ready: {plugin.name} v{plugin.version}\u0026#39;) print(f\u0026#39; ID: {plugin.id}\u0026#39;) print(f\u0026#39; Django apps: {plugin.django_apps}\u0026#39;) print(f\u0026#39; API patterns: {plugin.api_v2_patterns}\u0026#39;) \u0026#34; Expected Output:
✓ Plugin ready: My First Plugin v1.0.0 ID: my-first-plugin Django apps: [\u0026#39;my_first_plugin\u0026#39;] API patterns: my_first_plugin.api_v2.urls 3.3 Test with Pagoda Application Start Pagoda with your plugin enabled:
# Navigate to Pagoda repository cd /path/to/pagoda # Start server with plugin enabled ENABLED_PLUGINS=my-first python manage.py runserver 8080 Expected Logs on Success:
[INFO] Initializing plugin system... [INFO] Starting plugin discovery... [INFO] Loaded external plugin: my-first [INFO] Registered plugin: my-first-plugin v1.0.0 [INFO] Successfully injected models into plugin SDK [INFO] Registered 6 hook(s) for plugin \u0026#39;my-first-plugin\u0026#39; [INFO] Plugin discovery completed. Found 1 plugins. [INFO] Plugin system initialized successfully 3.4 Test Plugin API Endpoints In another terminal, test your plugin\u0026rsquo;s endpoints:
# Test the no-auth endpoint curl http://localhost:8080/api/v2/plugins/my-first/test/ # Test authenticated endpoint (requires valid token) curl -H \u0026#34;Authorization: Token YOUR_TOKEN\u0026#34; \\ http://localhost:8080/api/v2/plugins/my-first/hello/ Expected Response:
{ \u0026#34;message\u0026#34;: \u0026#34;Hello from My First Plugin!\u0026#34;, \u0026#34;plugin\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;my-first-plugin\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;My First Plugin\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34; }, \u0026#34;custom_data\u0026#34;: { \u0026#34;greeting\u0026#34;: \u0026#34;Welcome to plugin development!\u0026#34;, \u0026#34;tips\u0026#34;: \u0026#34;Check the documentation for advanced features\u0026#34; }, \u0026#34;timestamp\u0026#34;: \u0026#34;2025-10-12T12:34:56.789012\u0026#34; } 3.5 Test Hook Execution Create a test entity and entry to see your hooks in action:
# Watch server logs for hook messages # You should see log messages like: # [INFO] [My First Plugin] Entry created: \u0026#39;test-entry\u0026#39; in entity \u0026#39;TestEntity\u0026#39; by admin # [INFO] [My First Plugin] Getting entry attrs for: \u0026#39;test-entry\u0026#39; Practical Troubleshooting Issue 1: 404 Error - Plugin Not Found Symptoms:
curl http://localhost:8080/api/v2/plugins/my-plugin/test/ # 404 Not Found Diagnostic Steps:
# 1. Check if plugin system is enabled python manage.py shell -c \u0026#34; from django.conf import settings print(\u0026#39;Plugin system enabled:\u0026#39;, bool(getattr(settings, \u0026#39;ENABLED_PLUGINS\u0026#39;, []))) \u0026#34; # 2. Check plugin registration status ENABLED_PLUGINS=my-first-plugin python manage.py shell -c \u0026#34; from airone.plugins.integration import plugin_integration plugin_integration.initialize() plugins = plugin_integration.get_enabled_plugins() for p in plugins: print(f\u0026#39;Plugin: {p.id} - {p.name}\u0026#39;) \u0026#34; # 3. Check entry points python -c \u0026#34; import pkg_resources entries = list(pkg_resources.iter_entry_points(\u0026#39;pagoda.plugins\u0026#39;)) print(f\u0026#39;Found {len(entries)} entry points:\u0026#39;) for ep in entries: print(f\u0026#39; {ep.name} -\u0026gt; {ep.module_name}\u0026#39;) \u0026#34; Solutions:
# Most common cause: Missing environment variable ❌ python manage.py runserver ✅ ENABLED_PLUGINS=my-first-plugin python manage.py runserver # Second most common cause: Plugin not installed pip install -e . # Entry points path error # Check pyproject.toml and fix the path specification Issue 2: Import Error - Module Not Found Symptoms:
[ERROR] Failed to load external plugin: No module named \u0026#39;my_plugin\u0026#39; Diagnostic \u0026amp; Resolution Steps:
# 1. Check if plugin is installed correctly pip list | grep my-plugin # 2. Check module structure tree my-plugin/ # Expected structure: # my-plugin/ # ├── setup.py # └── my_plugin/ # ├── __init__.py # └── plugin.py # 3. Check and fix entry points path # In pyproject.toml: [project.entry-points.\u0026#34;pagoda.plugins\u0026#34;] my-plugin = \u0026#34;my_plugin.plugin:MyPlugin\u0026#34; # ← Exact path # 4. Reinstall pip uninstall -y my-plugin rm -rf build/ dist/ *.egg-info/ pip install -e . Issue 3: Hook Execution Error Symptoms:
[ERROR] Hook entry.after_create failed: missing required arguments Solutions:
# ❌ Incorrect signature (missing self and entity_name) @entry_hook(\u0026#34;after_create\u0026#34;) def log_entry_create(user, entry): pass # ❌ Missing decorator def log_entry_create(self, entity_name, user, entry, **kwargs): pass # ✅ Correct signature with decorator @entry_hook(\u0026#34;after_create\u0026#34;) def log_entry_create(self, entity_name, user, entry, **kwargs): \u0026#34;\u0026#34;\u0026#34; entity_name: Name of the entity user: User who created the entry entry: The created Entry instance **kwargs: Additional context \u0026#34;\u0026#34;\u0026#34; logger.info(f\u0026#34;New entry: {entry.name} in entity {entity_name}\u0026#34;) Issue 4: Entity Filtering Not Working Symptoms: Hook decorated with entity=\u0026quot;customer\u0026quot; is being called for all entities.
Diagnostic Steps:
# Check if entity parameter is specified correctly @entry_hook(\u0026#34;after_create\u0026#34;, entity=\u0026#34;customer\u0026#34;) # ✅ Correct def handle_customer(self, entity_name, user, entry, **kwargs): pass # Common mistakes: @entry_hook(\u0026#34;after_create\u0026#34;, entity_name=\u0026#34;customer\u0026#34;) # ❌ Wrong parameter name @entry_hook(\u0026#34;after_create\u0026#34;, entity=[\u0026#34;customer\u0026#34;]) # ❌ Should be string, not list Solution:
# Verify entity name matches exactly (case-sensitive) @entry_hook(\u0026#34;after_create\u0026#34;, entity=\u0026#34;Customer\u0026#34;) # Won\u0026#39;t match \u0026#34;customer\u0026#34; @entry_hook(\u0026#34;after_create\u0026#34;, entity=\u0026#34;customer\u0026#34;) # ✅ Correct # Check entity name in hook handler for debugging @entry_hook(\u0026#34;after_create\u0026#34;) def debug_entity_name(self, entity_name, user, entry, **kwargs): logger.info(f\u0026#34;Entity name received: \u0026#39;{entity_name}\u0026#39;\u0026#34;) # Use this to verify the actual entity name Issue 5: Wrong Decorator for Hook Type Symptoms:
[ERROR] Hook validation failed: unexpected arguments Solutions:
Each decorator is designed for specific hook types:
# ❌ Wrong decorator for validation hook @entry_hook(\u0026#34;validate\u0026#34;) def validate_entry(self, user, schema_name, name, attrs, instance, **kwargs): pass # ✅ Correct decorator @validation_hook() def validate_entry(self, user, schema_name, name, attrs, instance, **kwargs): pass # ❌ Wrong decorator for data access hook @entry_hook(\u0026#34;get_attrs\u0026#34;) def modify_attrs(self, entry, attrinfo, is_retrieve, **kwargs): pass # ✅ Correct decorator @get_attrs_hook(\u0026#34;entry\u0026#34;) def modify_attrs(self, entry, attrinfo, is_retrieve, **kwargs): return attrinfo Correct Decorator Usage:
@entry_hook() - For entry lifecycle (create, update, delete, restore) @entity_hook() - For entity lifecycle (create, update) @validation_hook() - For entry validation only @get_attrs_hook() - For data access hooks (entry/entity get_attrs) Issue 6: Hook Priority Not Working as Expected Symptoms: Hooks are executing in unexpected order despite setting priority values.
Solution:
# Remember: Lower priority number = Higher priority (executes first) class MyPlugin(Plugin): @entry_hook(\u0026#34;after_create\u0026#34;, priority=50) # Executes FIRST def first_handler(self, entity_name, user, entry, **kwargs): pass @entry_hook(\u0026#34;after_create\u0026#34;, priority=100) # Executes SECOND (default) def second_handler(self, entity_name, user, entry, **kwargs): pass @entry_hook(\u0026#34;after_create\u0026#34;, priority=150) # Executes LAST def third_handler(self, entity_name, user, entry, **kwargs): pass Debugging Priority Issues:
# Add logging to verify execution order @entry_hook(\u0026#34;after_create\u0026#34;, priority=50) def handler_a(self, entity_name, user, entry, **kwargs): logger.info(f\u0026#34;Handler A executing (priority 50)\u0026#34;) @entry_hook(\u0026#34;after_create\u0026#34;, priority=100) def handler_b(self, entity_name, user, entry, **kwargs): logger.info(f\u0026#34;Handler B executing (priority 100)\u0026#34;) # Check logs to verify execution order: # [INFO] Handler A executing (priority 50) # [INFO] Handler B executing (priority 100) Issue 7: Data Access Hook Not Returning Modified Data Symptoms:
[ERROR] get_attrs_hook must return attrinfo list Solution:
# ❌ Forgot to return modified attrinfo @get_attrs_hook(\u0026#34;entry\u0026#34;) def modify_attrs(self, entry, attrinfo, is_retrieve, **kwargs): for attr in attrinfo: attr[\u0026#34;custom_field\u0026#34;] = \u0026#34;value\u0026#34; # Missing return statement! # ✅ Correct: Always return the modified attrinfo @get_attrs_hook(\u0026#34;entry\u0026#34;) def modify_attrs(self, entry, attrinfo, is_retrieve, **kwargs): for attr in attrinfo: attr[\u0026#34;custom_field\u0026#34;] = \u0026#34;value\u0026#34; return attrinfo # Must return! # ✅ Even if no modifications, return the original @get_attrs_hook(\u0026#34;entry\u0026#34;) def no_modification(self, entry, attrinfo, is_retrieve, **kwargs): logger.info(\u0026#34;Hook called but no changes needed\u0026#34;) return attrinfo # Still must return! Accessing Host Application Models Overview Plugins can access Pagoda\u0026rsquo;s models (Entity, Entry, User, etc.) through the plugin SDK\u0026rsquo;s model injection mechanism. This provides type-safe access to host application data.
Basic Model Import # Import models from the plugin SDK from pagoda_plugin_sdk.models import Entity, Entry, User class MyPluginView(PluginAPIViewMixin): def get(self, request): # Access models directly entities = Entity.objects.filter(is_active=True) entries = Entry.objects.filter(schema__name=\u0026#34;MyEntity\u0026#34;) Entity Access Examples List All Entities:
from pagoda_plugin_sdk.models import Entity from rest_framework.response import Response class EntityListView(PluginAPIViewMixin): def get(self, request): # Get all active entities entities = Entity.objects.filter(is_active=True) # Convert to response format entity_list = [] for entity in entities: entity_list.append({ \u0026#34;id\u0026#34;: entity.id, \u0026#34;name\u0026#34;: entity.name, \u0026#34;note\u0026#34;: entity.note, \u0026#34;created_user\u0026#34;: entity.created_user.username if entity.created_user else None, }) return Response({\u0026#34;entities\u0026#34;: entity_list, \u0026#34;count\u0026#34;: len(entity_list)}) Get Entity Details:
from pagoda_plugin_sdk.models import Entity class EntityDetailView(PluginAPIViewMixin): def get(self, request, entity_id): try: entity = Entity.objects.get(id=entity_id, is_active=True) return Response({ \u0026#34;id\u0026#34;: entity.id, \u0026#34;name\u0026#34;: entity.name, \u0026#34;note\u0026#34;: entity.note, \u0026#34;is_active\u0026#34;: entity.is_active, \u0026#34;created_time\u0026#34;: entity.created_time.isoformat() if entity.created_time else None, }) except Entity.DoesNotExist: return Response( {\u0026#34;error\u0026#34;: f\u0026#34;Entity {entity_id} not found\u0026#34;}, status=404 ) Entry Access Examples List Entries with Filtering:
from pagoda_plugin_sdk.models import Entry class EntryListView(PluginAPIViewMixin): def get(self, request): # Get query parameters entity_id = request.GET.get(\u0026#34;entity_id\u0026#34;) limit = request.GET.get(\u0026#34;limit\u0026#34;, 100) # Build query queryset = Entry.objects.filter(is_active=True) if entity_id: queryset = queryset.filter(schema_id=entity_id) # Limit results entries = queryset[:int(limit)] # Format response entry_list = [] for entry in entries: entry_list.append({ \u0026#34;id\u0026#34;: entry.id, \u0026#34;name\u0026#34;: entry.name, \u0026#34;entity\u0026#34;: { \u0026#34;id\u0026#34;: entry.schema.id, \u0026#34;name\u0026#34;: entry.schema.name, } if entry.schema else None, \u0026#34;created_user\u0026#34;: entry.created_user.username if entry.created_user else None, }) return Response({ \u0026#34;entries\u0026#34;: entry_list, \u0026#34;count\u0026#34;: len(entry_list), \u0026#34;filters\u0026#34;: {\u0026#34;entity_id\u0026#34;: entity_id, \u0026#34;limit\u0026#34;: limit} }) Get Entry with Attributes:
from pagoda_plugin_sdk.models import Entry class EntryDetailView(PluginAPIViewMixin): def get(self, request, entry_id): try: entry = Entry.objects.get(id=entry_id, is_active=True) # Use Entry\u0026#39;s custom method to get attributes attrs = entry.get_attrs() return Response({ \u0026#34;id\u0026#34;: entry.id, \u0026#34;name\u0026#34;: entry.name, \u0026#34;entity\u0026#34;: { \u0026#34;id\u0026#34;: entry.schema.id, \u0026#34;name\u0026#34;: entry.schema.name, }, \u0026#34;attributes\u0026#34;: attrs, # All entry attributes \u0026#34;created_time\u0026#34;: entry.created_time.isoformat() if entry.created_time else None, }) except Entry.DoesNotExist: return Response( {\u0026#34;error\u0026#34;: f\u0026#34;Entry {entry_id} not found\u0026#34;}, status=404 ) Working with Relationships from pagoda_plugin_sdk.models import Entity, Entry class EntityEntriesView(PluginAPIViewMixin): def get(self, request, entity_id): \u0026#34;\u0026#34;\u0026#34;Get an entity and all its entries\u0026#34;\u0026#34;\u0026#34; try: # Get entity entity = Entity.objects.get(id=entity_id, is_active=True) # Get all entries for this entity entries = Entry.objects.filter( schema=entity, is_active=True ).select_related(\u0026#39;created_user\u0026#39;) # Format response return Response({ \u0026#34;entity\u0026#34;: { \u0026#34;id\u0026#34;: entity.id, \u0026#34;name\u0026#34;: entity.name, }, \u0026#34;entries\u0026#34;: [ { \u0026#34;id\u0026#34;: e.id, \u0026#34;name\u0026#34;: e.name, \u0026#34;created_user\u0026#34;: e.created_user.username, } for e in entries ], \u0026#34;total_entries\u0026#34;: entries.count() }) except Entity.DoesNotExist: return Response({\u0026#34;error\u0026#34;: \u0026#34;Entity not found\u0026#34;}, status=404) Model Availability Check Always check if models are available before using them:
from pagoda_plugin_sdk.models import Entity from pagoda_plugin_sdk import models class SafeModelView(PluginAPIViewMixin): def get(self, request): # Check if plugin system is initialized if not models.is_initialized(): return Response( {\u0026#34;error\u0026#34;: \u0026#34;Plugin system not initialized\u0026#34;}, status=503 ) # Check specific model if Entity is None: return Response( {\u0026#34;error\u0026#34;: \u0026#34;Entity model not available\u0026#34;}, status=503 ) # Safe to use models entities = Entity.objects.all() return Response({\u0026#34;count\u0026#34;: entities.count()}) Type-Safe Model Usage Use Protocol types for better type safety:
from typing import List from pagoda_plugin_sdk.models import Entity, Entry from pagoda_plugin_sdk.protocols import EntityProtocol, EntryProtocol def process_entity(entity: EntityProtocol) -\u0026gt; dict: \u0026#34;\u0026#34;\u0026#34;Process entity with type safety Args: entity: Entity instance (type-safe) Returns: Processed entity data \u0026#34;\u0026#34;\u0026#34; return { \u0026#34;id\u0026#34;: entity.id, \u0026#34;name\u0026#34;: entity.name, \u0026#34;note\u0026#34;: entity.note, } def get_entity_entries(entity: EntityProtocol) -\u0026gt; List[EntryProtocol]: \u0026#34;\u0026#34;\u0026#34;Get entries for entity with type hints Args: entity: Entity to get entries for Returns: List of Entry instances \u0026#34;\u0026#34;\u0026#34; return Entry.objects.filter(schema=entity, is_active=True) Error Handling Best Practices from pagoda_plugin_sdk.models import Entity, Entry from rest_framework.response import Response from rest_framework import status class RobustModelView(PluginAPIViewMixin): def get(self, request, entity_id): try: # Model availability check if Entity is None or Entry is None: return Response( {\u0026#34;error\u0026#34;: \u0026#34;Models not available\u0026#34;}, status=status.HTTP_503_SERVICE_UNAVAILABLE ) # Get entity entity = Entity.objects.get(id=entity_id, is_active=True) # Get entries entries = Entry.objects.filter(schema=entity, is_active=True) return Response({ \u0026#34;entity\u0026#34;: {\u0026#34;id\u0026#34;: entity.id, \u0026#34;name\u0026#34;: entity.name}, \u0026#34;entry_count\u0026#34;: entries.count() }) except Entity.DoesNotExist: return Response( {\u0026#34;error\u0026#34;: f\u0026#34;Entity {entity_id} not found\u0026#34;}, status=status.HTTP_404_NOT_FOUND ) except Exception as e: return Response( {\u0026#34;error\u0026#34;: \u0026#34;Internal error\u0026#34;, \u0026#34;detail\u0026#34;: str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR ) Advanced Development Techniques Inter-Plugin Communication # Plugin A: Data provider class PluginA(Plugin): def get_shared_data(self): return {\u0026#34;key\u0026#34;: \u0026#34;value\u0026#34;} # Plugin B: Data consumer class PluginB(Plugin): def use_shared_data(self): from airone.plugins.registry import plugin_registry plugin_a = plugin_registry.get_plugin(\u0026#34;plugin-a\u0026#34;) if plugin_a: data = plugin_a.get_shared_data() return data Data Access Using Model Injection # Access Pagoda data from plugin from pagoda_plugin_sdk import PluginAPIViewMixin from pagoda_plugin_sdk.models import Entity, Entry class DataAccessView(PluginAPIViewMixin): def get(self, request, entity_id): # Type-safe model access try: if Entity is None: return Response( {\u0026#34;error\u0026#34;: \u0026#34;Entity model not available\u0026#34;}, status=503 ) entity = Entity.objects.get(id=entity_id, is_active=True) entries = Entry.objects.filter(schema=entity, is_active=True) return Response({ \u0026#34;entity\u0026#34;: { \u0026#34;id\u0026#34;: entity.id, \u0026#34;name\u0026#34;: entity.name, }, \u0026#34;entry_count\u0026#34;: entries.count() }) except Entity.DoesNotExist: return Response({\u0026#34;error\u0026#34;: \u0026#34;Entity not found\u0026#34;}, status=404) except Exception as e: return Response({\u0026#34;error\u0026#34;: str(e)}, status=500) Conditional Hook Execution @entry_hook(\u0026#34;after_create\u0026#34;) def conditional_hook(self, entity_name, user, entry, **kwargs): # Execute only under specific conditions if entry.name.startswith(\u0026#34;special_\u0026#34;): # Special processing logger.info(f\u0026#34;Special entry detected: {entry.name}\u0026#34;) # Example of external API call import requests try: response = requests.post(\u0026#34;https://api.example.com/notify\u0026#34;, { \u0026#34;entry_name\u0026#34;: entry.name, \u0026#34;entity_name\u0026#34;: entity_name, \u0026#34;plugin\u0026#34;: \u0026#34;my-first-plugin\u0026#34; }, timeout=5) logger.info(f\u0026#34;External API notified: {response.status_code}\u0026#34;) except requests.RequestException as e: logger.error(f\u0026#34;Failed to notify external API: {e}\u0026#34;) Performance Optimization Asynchronous Hook Execution import asyncio from concurrent.futures import ThreadPoolExecutor @entry_hook(\u0026#34;after_create\u0026#34;) def async_hook_handler(self, entity_name, user, entry, **kwargs): \u0026#34;\u0026#34;\u0026#34;Execute heavy processing asynchronously\u0026#34;\u0026#34;\u0026#34; def heavy_processing(): # Heavy processing (external API, file processing, etc.) import time time.sleep(2) # Example: Simulate heavy processing logger.info(f\u0026#34;Heavy processing completed for {entry.name}\u0026#34;) # Execute in background executor = ThreadPoolExecutor(max_workers=2) executor.submit(heavy_processing) Conditional Hook Branching @entry_hook(\u0026#34;after_create\u0026#34;) def optimized_hook(self, entity_name, user, entry, **kwargs): # Skip unnecessary processing if not self.should_process(entry): return # Execute heavy processing only when necessary if entry.name.endswith(\u0026#34;_important\u0026#34;): self.heavy_processing(entry) else: self.light_processing(entry) def should_process(self, entry): # Determine if processing is necessary return hasattr(entry, \u0026#39;special_flag\u0026#39;) and entry.special_flag Production Distribution Preparation Building Your Plugin Before distributing your plugin, you need to build it into a distributable package.
Option A: Using build tool (standard) # Install build tool if not already installed pip install build # Build distribution packages python -m build # This creates: # dist/my_first_plugin-1.0.0-py3-none-any.whl (wheel package) # dist/my_first_plugin-1.0.0.tar.gz (source distribution) Option B: Using uv (recommended - faster) # Build with uv uv build # Creates the same dist/ files Publishing Your Plugin To PyPI (Public) # Install twine if needed pip install twine # Upload to PyPI python -m twine upload dist/* # Or using uv uv publish To TestPyPI (For Testing) # Upload to TestPyPI first to test python -m twine upload --repository testpypi dist/* # Test installation from TestPyPI pip install --index-url https://test.pypi.org/simple/ my-first-plugin To GitHub Releases # Create a git tag git tag v1.0.0 git push origin v1.0.0 # Upload wheel file to GitHub release # Users can install with: # pip install https://github.com/you/my-plugin/releases/download/v1.0.0/my_first_plugin-1.0.0-py3-none-any.whl Production-Ready pyproject.toml Update your pyproject.toml with complete metadata for production:
[project] name = \u0026#34;my-first-plugin\u0026#34; version = \u0026#34;1.0.0\u0026#34; description = \u0026#34;A production-ready Pagoda plugin\u0026#34; readme = \u0026#34;README.md\u0026#34; license = {text = \u0026#34;MIT\u0026#34;} authors = [ {name = \u0026#34;Your Name\u0026#34;, email = \u0026#34;you@example.com\u0026#34;} ] keywords = [\u0026#34;pagoda\u0026#34;, \u0026#34;plugin\u0026#34;, \u0026#34;yourfeature\u0026#34;] classifiers = [ \u0026#34;Development Status :: 4 - Beta\u0026#34;, \u0026#34;Environment :: Web Environment\u0026#34;, \u0026#34;Framework :: Django\u0026#34;, \u0026#34;Framework :: Django :: 3.2\u0026#34;, \u0026#34;Framework :: Django :: 4.0\u0026#34;, \u0026#34;Framework :: Django :: 4.1\u0026#34;, \u0026#34;Framework :: Django :: 4.2\u0026#34;, \u0026#34;Intended Audience :: Developers\u0026#34;, \u0026#34;License :: OSI Approved :: MIT License\u0026#34;, \u0026#34;Operating System :: OS Independent\u0026#34;, \u0026#34;Programming Language :: Python\u0026#34;, \u0026#34;Programming Language :: Python :: 3\u0026#34;, \u0026#34;Programming Language :: Python :: 3.8\u0026#34;, \u0026#34;Programming Language :: Python :: 3.9\u0026#34;, \u0026#34;Programming Language :: Python :: 3.10\u0026#34;, \u0026#34;Programming Language :: Python :: 3.11\u0026#34;, \u0026#34;Programming Language :: Python :: 3.12\u0026#34;, \u0026#34;Topic :: Internet :: WWW/HTTP\u0026#34;, ] dependencies = [ \u0026#34;pagoda-plugin-sdk @ git+https://github.com/dmm-com/pagoda.git#subdirectory=plugin/sdk\u0026#34;, \u0026#34;Django\u0026gt;=3.2\u0026#34;, \u0026#34;djangorestframework\u0026gt;=3.12\u0026#34;, ] requires-python = \u0026#34;\u0026gt;=3.8\u0026#34; [project.urls] Homepage = \u0026#34;https://github.com/youruser/my-first-plugin\u0026#34; Documentation = \u0026#34;https://my-plugin-docs.example.com\u0026#34; Repository = \u0026#34;https://github.com/youruser/my-first-plugin.git\u0026#34; Issues = \u0026#34;https://github.com/youruser/my-first-plugin/issues\u0026#34; Changelog = \u0026#34;https://github.com/youruser/my-first-plugin/blob/main/CHANGELOG.md\u0026#34; [project.entry-points.\u0026#34;pagoda.plugins\u0026#34;] my-first = \u0026#34;my_first_plugin.plugin:MyFirstPlugin\u0026#34; [build-system] requires = [\u0026#34;hatchling\u0026#34;] build-backend = \u0026#34;hatchling.build\u0026#34; [tool.hatch.build.targets.wheel] packages = [\u0026#34;my_first_plugin\u0026#34;] Continuous Integration with GitHub Actions Create .github/workflows/test.yml:
name: Test and Build Plugin on: [push, pull_request] jobs: test: runs-on: ubuntu-latest strategy: matrix: python-version: [\u0026#34;3.8\u0026#34;, \u0026#34;3.9\u0026#34;, \u0026#34;3.10\u0026#34;, \u0026#34;3.11\u0026#34;, \u0026#34;3.12\u0026#34;] steps: - uses: actions/checkout@v4 - name: Install uv uses: astral-sh/setup-uv@v4 with: version: \u0026#34;latest\u0026#34; - name: Set up Python run: uv python install \${{ matrix.python-version }} - name: Install dependencies run: | uv pip install git+https://github.com/dmm-com/pagoda.git#subdirectory=plugin/sdk uv pip install -e . uv pip install pytest - name: Run tests run: | uv run pytest tests/ - name: Test plugin loading run: | uv run python -c \u0026#34;from my_first_plugin.plugin import MyFirstPlugin; print(\u0026#39;✓ Plugin loads successfully\u0026#39;)\u0026#34; build: needs: test runs-on: ubuntu-latest if: startsWith(github.ref, \u0026#39;refs/tags/v\u0026#39;) steps: - uses: actions/checkout@v4 - name: Install uv uses: astral-sh/setup-uv@v4 - name: Build package run: uv build - name: Upload artifacts uses: actions/upload-artifact@v4 with: name: dist path: dist/ - name: Publish to PyPI if: github.event_name == \u0026#39;push\u0026#39; \u0026amp;\u0026amp; startsWith(github.ref, \u0026#39;refs/tags\u0026#39;) env: UV_PUBLISH_TOKEN: \${{ secrets.PYPI_API_TOKEN }} run: uv publish Version Management Best Practices Update version in pyproject.toml
version = \u0026#34;1.0.1\u0026#34; # Semantic versioning Create git tag
git tag v1.0.1 git push origin v1.0.1 Maintain CHANGELOG.md
# Changelog ## [1.0.1] - 2025-10-12 ### Fixed - Bug fix description ## [1.0.0] - 2025-10-01 ### Added - Initial release Installation Instructions for Users Once published, users can install your plugin:
# From PyPI pip install my-first-plugin # From Git repository pip install git+https://github.com/youruser/my-first-plugin.git # From Git tag pip install git+https://github.com/youruser/my-first-plugin.git@v1.0.0 # Using uv (faster) uv pip install my-first-plugin Then enable it in their Pagoda installation:
export ENABLED_PLUGINS=my-first python manage.py runserver Summary By following this quick start guide, you can create a working Pagoda plugin in 5 minutes:
✅ Install pagoda-plugin-sdk ✅ Create plugin structure with pyproject.toml ✅ Implement plugin with decorators (@entry_hook, @entity_hook, etc.) ✅ Test with development installation ✅ Build and distribute with uv or pip For more detailed information, refer to:
Plugin System Documentation - Complete reference Plugin Architecture Diagrams - Visual architecture `}),e.add({id:3,href:"/advanced/",title:"Advanced Topics",parent:"Pagoda",content:`Advanced AirOne Features This section covers advanced topics for extending and customizing AirOne.
Plugin System AirOne\u0026rsquo;s powerful plugin system allows you to create and distribute independent plugins as external packages.
Plugin System - Plugin system overview, development guide, and troubleshooting Architecture Diagrams - Detailed architecture diagrams and system design Quick Start Guide - Practical guide to start plugin development in 5 minutes Other Advanced Features Advanced Search - Advanced search functionality Custom View - Custom view implementation Frontend Architecture - Frontend design Google Spreadsheet Linkage - Google Spreadsheet integration Categories - Category features `}),e.add({id:4,href:"/release_note/CHANGELOG/",title:"Changelog",parent:"Release Notes",content:"in development Fixed Fixed a bug not to change referral values when entity was edited v2.4.0 Changed Change implementation about editing Entity to disable to edit type of EntityAttr v2.3.1 Fixed Fixed a problem that date value won\u0026rsquo;t be shown at advanced search result v2.3.0 Added Added new AttributeType array group that could contain multiple Group referral in an Attribute value v2.2.0 Added Added a method in Entry to get an AttributeValue from Entry object with a small number of SQL v2.1.0 Added Added an API endpoint that returns change history of specific entry\u0026rsquo;s attribute. Added a feature to be able to confirm job of deleting entry from Job list view (#10) v2.0.1 Fixed Fixed a bug that mandatory parameter was able to be updated with empty value by specifying \u0026lsquo;- NOT SET -\u0026rsquo; value (#20) v2.0.0 Added Added a new optional authentication feature which is able to authenticate user with LDAP server (#6) "}),e.add({id:5,href:"/getting_started/installation/",title:"Installation and Configuration",parent:"Getting Started",content:`(TBD)
`}),e.add({id:6,href:"/posts/",title:"News",parent:"Pagoda",content:""}),e.add({id:7,href:"/advanced/frontend_plugin_development/",title:"Frontend Plugin Development",parent:"Advanced Topics",content:`Airone Plugin Development Guide This guide explains how to create, develop, and distribute plugins for the Airone frontend using the new simplified plugin architecture.
🎯 Overview Airone uses an extremely simplified plugin system that focuses on the core principle: \u0026ldquo;just connecting routing with React Components\u0026rdquo;. This eliminates complex lifecycle management, API layers, and dependency systems in favor of a minimal, type-safe approach.
🏗️ Simplified Plugin Architecture Plugin System Architecture graph TB subgraph \u0026#34;Developer Work\u0026#34; A[plugins.config.js Plugin Configuration] --\u0026gt; B[npm run build] B --\u0026gt; C[generate-plugin-imports.js Auto-executed] end subgraph \u0026#34;Build Process\u0026#34; C --\u0026gt; D[src/generatedPlugins.ts Auto-generated] D --\u0026gt; E[Webpack Bundle] F[src/App.tsx] --\u0026gt; E G[pagoda-core types] --\u0026gt; E end subgraph \u0026#34;Runtime\u0026#34; E --\u0026gt; H[Distributable ui.js] H --\u0026gt; I[Browser] end subgraph \u0026#34;Plugin System\u0026#34; J[Plugin Interface] --\u0026gt; K[id, name, version, routes] L[PluginRoute Interface] --\u0026gt; M[path and element] N[extractRoutes Function] --\u0026gt; O[Plugin to CustomRoute] end subgraph \u0026#34;Individual Plugins\u0026#34; P[pagoda-plugin-hello-world] --\u0026gt; P1[Hello World Route] Q[pagoda-plugin-dashboard] --\u0026gt; Q1[Dashboard Route] end subgraph \u0026#34;Integration Flow\u0026#34; R[AppBase Component] --\u0026gt; S[Receives plugins array] S --\u0026gt; T[Executes extractRoutes] T --\u0026gt; U[Merges with existing routes] U --\u0026gt; V[Passes to AppRouter] end A -.-\u0026gt; P A -.-\u0026gt; Q P --\u0026gt; D Q --\u0026gt; D K --\u0026gt; R J --\u0026gt; P J --\u0026gt; Q L --\u0026gt; K N --\u0026gt; T style A fill:#e1f5fe style C fill:#f3e5f5 style D fill:#fff3e0 style J fill:#e8f5e8 style R fill:#fff8e1 Key Principles Extreme Simplification: Plugin interface contains only id, name, version, and routes No Lifecycle Management: Removed initialize, activate, deactivate hooks No Plugin API: Direct component implementation without API layers Configuration-Based: Managed through plugins.config.js only Type Safety: Enforced using TypeScript\u0026rsquo;s satisfies operator 🚀 Getting Started 1. Prerequisites Node.js 18+ and npm 8+ TypeScript 5.0+ Basic knowledge of React and TypeScript Understanding of npm package development and local linking 2. Manual Setup Create a new plugin directory:
mkdir pagoda-plugin-my-feature cd pagoda-plugin-my-feature npm init -y Install peer dependencies:
npm install --save-peer @dmm-com/pagoda-core react react-dom @mui/material @mui/icons-material npm install --save-dev @types/react @types/react-dom typescript Configure TypeScript:
// tsconfig.json { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;ES2020\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;CommonJS\u0026#34;, \u0026#34;lib\u0026#34;: [\u0026#34;ES2020\u0026#34;, \u0026#34;DOM\u0026#34;], \u0026#34;declaration\u0026#34;: true, \u0026#34;outDir\u0026#34;: \u0026#34;./dist\u0026#34;, \u0026#34;strict\u0026#34;: true, \u0026#34;esModuleInterop\u0026#34;: true, \u0026#34;jsx\u0026#34;: \u0026#34;react-jsx\u0026#34; }, \u0026#34;include\u0026#34;: [\u0026#34;src/**/*\u0026#34;], \u0026#34;exclude\u0026#34;: [\u0026#34;node_modules\u0026#34;, \u0026#34;dist\u0026#34;] } 📋 Simplified Plugin Structure Plugin Interface (Simplified) // Provided by @dmm-com/pagoda-core export interface Plugin { id: string; // Unique identifier name: string; // Display name version: string; // Semver version routes: PluginRoute[]; // Route definitions } export interface PluginRoute { path: string; // Route path (recommend /ui/ prefix) element: ReactNode; // React component element } Route Configuration Simple: Only path and element required Type Safe: Use satisfies Plugin for compile-time validation No Complexity: No lifecycle hooks, priorities, or API dependencies Basic Plugin Example // src/index.ts import React from \u0026#34;react\u0026#34;; import type { Plugin } from \u0026#34;@dmm-com/pagoda-core\u0026#34;; import MyPluginPage from \u0026#34;./components/MyPluginPage\u0026#34;; const myPlugin = { id: \u0026#34;my-awesome-plugin\u0026#34;, name: \u0026#34;My Awesome Plugin\u0026#34;, version: \u0026#34;1.0.0\u0026#34;, routes: [ { path: \u0026#34;/ui/my-plugin\u0026#34;, element: React.createElement(MyPluginPage), }, ], } satisfies Plugin; // Type safety enforcement export default myPlugin; Component Implementation // src/components/MyPluginPage.tsx import React, { useState } from \u0026#34;react\u0026#34;; import { Box, Typography, Card, CardContent, Button } from \u0026#34;@mui/material\u0026#34;; // Optional: Plugin API integration (passed as props if available) export interface MyPluginPageProps { pluginAPI?: { ui?: { showNotification?: (message: string, type: string) =\u0026gt; void }; routing?: { navigate?: (path: string) =\u0026gt; void }; }; } const MyPluginPage: React.FC\u0026lt;MyPluginPageProps\u0026gt; = ({ pluginAPI }) =\u0026gt; { const [count, setCount] = useState(0); const handleClick = () =\u0026gt; { setCount(prev =\u0026gt; prev + 1); // Optional: Use plugin API if available if (pluginAPI?.ui?.showNotification) { pluginAPI.ui.showNotification(\`Clicked \${count + 1} times!\`, \u0026#34;success\u0026#34;); } }; return ( \u0026lt;Box sx={{ p: 3 }}\u0026gt; \u0026lt;Typography variant=\u0026#34;h4\u0026#34; gutterBottom\u0026gt; My Awesome Plugin \u0026lt;/Typography\u0026gt; \u0026lt;Card\u0026gt; \u0026lt;CardContent\u0026gt; \u0026lt;Typography variant=\u0026#34;body1\u0026#34; paragraph\u0026gt; This is a demonstration of the simplified plugin system. \u0026lt;/Typography\u0026gt; \u0026lt;Button variant=\u0026#34;contained\u0026#34; onClick={handleClick}\u0026gt; Click Me ({count}) \u0026lt;/Button\u0026gt; \u0026lt;/CardContent\u0026gt; \u0026lt;/Card\u0026gt; \u0026lt;/Box\u0026gt; ); }; export default MyPluginPage; 🎨 Development Guidelines Naming Conventions Package Name: Use pagoda-plugin- prefix
✅ pagoda-plugin-reports ✅ pagoda-plugin-user-management ❌ my-pagoda-plugin Plugin ID: Use kebab-case
✅ reports-dashboard ✅ user-management ❌ ReportsDashboard Routes: Use descriptive paths with /ui/ prefix
✅ /ui/reports/dashboard ✅ /ui/user-management/settings ❌ /reports (missing /ui/ prefix) Integration with pagoda-minimal-builder Add to plugins.config.js:
// plugins.config.js export default { plugins: [ \u0026#34;pagoda-plugin-hello-world\u0026#34;, \u0026#34;pagoda-plugin-dashboard\u0026#34;, \u0026#34;pagoda-plugin-your-plugin\u0026#34;, // Add here ], }; Install locally for development:
# In pagoda-minimal-builder directory npm link ../path/to/your-plugin npm run build npm run start Verify integration:
Check browser console for loading messages Navigate to your plugin\u0026rsquo;s route Verify component renders correctly Component Development Best Practices Use React functional components with TypeScript Export component interfaces for type safety Follow Material-UI design patterns Implement responsive design Handle optional pluginAPI props gracefully Package.json Configuration { \u0026#34;name\u0026#34;: \u0026#34;pagoda-plugin-my-feature\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;dist/index.js\u0026#34;, \u0026#34;types\u0026#34;: \u0026#34;dist/index.d.ts\u0026#34;, \u0026#34;files\u0026#34;: [\u0026#34;dist\u0026#34;, \u0026#34;src\u0026#34;], \u0026#34;scripts\u0026#34;: { \u0026#34;build\u0026#34;: \u0026#34;tsc\u0026#34;, \u0026#34;typecheck\u0026#34;: \u0026#34;tsc --noEmit\u0026#34;, \u0026#34;clean\u0026#34;: \u0026#34;rm -rf dist\u0026#34; }, \u0026#34;peerDependencies\u0026#34;: { \u0026#34;@dmm-com/pagoda-core\u0026#34;: \u0026#34;^1.1.0\u0026#34;, \u0026#34;react\u0026#34;: \u0026#34;^18.0.0\u0026#34;, \u0026#34;react-dom\u0026#34;: \u0026#34;^18.0.0\u0026#34;, \u0026#34;@mui/material\u0026#34;: \u0026#34;^6.0.0\u0026#34;, \u0026#34;@mui/icons-material\u0026#34;: \u0026#34;^6.0.0\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@types/react\u0026#34;: \u0026#34;^18.0.0\u0026#34;, \u0026#34;@types/react-dom\u0026#34;: \u0026#34;^18.0.0\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;^5.0.0\u0026#34; } } 🔧 Plugin Features Multi-Route Plugins Support multiple pages within a single plugin:
const myPlugin = { id: \u0026#34;my-multi-page-plugin\u0026#34;, name: \u0026#34;My Multi-Page Plugin\u0026#34;, version: \u0026#34;1.0.0\u0026#34;, routes: [ { path: \u0026#34;/ui/my-plugin\u0026#34;, element: React.createElement(DashboardPage) }, { path: \u0026#34;/ui/my-plugin/settings\u0026#34;, element: React.createElement(SettingsPage) }, { path: \u0026#34;/ui/my-plugin/reports\u0026#34;, element: React.createElement(ReportsPage) } ], } satisfies Plugin; Route Overrides Override existing application routes:
// Override the default dashboard const dashboardPlugin = { id: \u0026#34;enhanced-dashboard\u0026#34;, name: \u0026#34;Enhanced Dashboard\u0026#34;, version: \u0026#34;1.0.0\u0026#34;, routes: [ { path: \u0026#34;/ui/dashboard\u0026#34;, // Override existing dashboard element: React.createElement(EnhancedDashboard) } ], } satisfies Plugin; State Management Use React Context for plugin-wide state:
import React, { createContext, useContext, useState } from \u0026#39;react\u0026#39;; interface PluginState { isLoaded: boolean; data: any[]; } const PluginContext = createContext\u0026lt;PluginState | null\u0026gt;(null); export const PluginProvider: React.FC\u0026lt;{children: React.ReactNode}\u0026gt; = ({children}) =\u0026gt; { const [state, setState] = useState\u0026lt;PluginState\u0026gt;({ isLoaded: false, data: [] }); return ( \u0026lt;PluginContext.Provider value={state}\u0026gt; {children} \u0026lt;/PluginContext.Provider\u0026gt; ); }; export const usePluginState = () =\u0026gt; { const context = useContext(PluginContext); if (!context) throw new Error(\u0026#39;usePluginState must be used within PluginProvider\u0026#39;); return context; }; 🏗️ Building and Testing Local Development # Build TypeScript npm run build # Type checking only npm run typecheck # Clean build artifacts npm run clean Local Testing with pagoda-minimal-builder Using npm link (recommended):
# In your plugin directory npm run build npm link # In pagoda-minimal-builder directory npm link pagoda-plugin-your-name Add to plugins.config.js:
export default { plugins: [ \u0026#34;pagoda-plugin-hello-world\u0026#34;, \u0026#34;pagoda-plugin-your-name\u0026#34;, // Your plugin ], }; Test integration:
# In pagoda-minimal-builder directory npm run build npm run start Integration Testing Verify your plugin works correctly:
Check browser console for loading messages Navigate to plugin routes in browser Test component functionality Verify TypeScript compilation without errors 📦 Distribution Local Distribution For local/internal use:
Build your plugin with npm run build Use npm link for development testing Use npm pack to create distributable package Publishing to npm (Optional) For public distribution:
# Ensure proper configuration npm run build # Version your plugin npm version patch # or minor/major # Publish (if public) npm publish Installation by Users Users can install your plugin in their pagoda-minimal-builder:
# Install the plugin npm install pagoda-plugin-your-name # Add to plugins.config.js # Then run build npm run build 🐛 Troubleshooting Common Issues Plugin Not Loading Check naming: Ensure package name starts with pagoda-plugin- Verify export: Plugin should be default export Check plugins.config.js: Ensure plugin is listed in configuration Verify build: Check src/generatedPlugins.ts was auto-generated TypeScript Errors Install peer dependencies: Make sure all peer deps are available Check imports: Verify import type { Plugin } from \u0026quot;@dmm-com/pagoda-core\u0026quot; Use satisfies: Ensure you use satisfies Plugin syntax Update types: Use compatible versions of dependencies Runtime Errors Check console: Look for error messages in browser console Verify imports: Ensure all imported modules are available Test components: Test React components independently Check paths: Verify route paths are accessible Routes Not Working Path format: Ensure paths start with /ui/ React.createElement: Verify proper component element creation Component export: Ensure components are properly exported Debug Tips Add logging to your plugin:
const myPlugin = { id: \u0026#34;my-plugin\u0026#34;, name: \u0026#34;My Plugin\u0026#34;, version: \u0026#34;1.0.0\u0026#34;, routes: [ { path: \u0026#34;/ui/my-plugin\u0026#34;, element: React.createElement(() =\u0026gt; { console.log(\u0026#39;[MyPlugin] Component rendering\u0026#39;); return React.createElement(\u0026#39;div\u0026#39;, {}, \u0026#39;Hello from My Plugin!\u0026#39;); }), }, ], } satisfies Plugin; console.log(\u0026#39;[MyPlugin] Plugin defined:\u0026#39;, myPlugin); export default myPlugin; 🎯 Best Practices Development Use TypeScript: Ensure type safety with satisfies Plugin Export interfaces: Export component prop interfaces for type safety Handle errors gracefully: Wrap components in error boundaries Consistent naming: Follow kebab-case for IDs and paths Documentation: Comment your plugin code clearly Performance Lazy loading: Use dynamic imports for heavy components React.memo: Use memoization for expensive components Minimize bundle: Keep dependencies lean Optimize images: Use appropriate image formats and sizes Accessibility Semantic HTML: Use proper HTML elements Keyboard navigation: Ensure all interactive elements are keyboard accessible Screen readers: Provide proper ARIA labels and descriptions Color contrast: Follow WCAG guidelines for color contrast 📚 Examples Minimal Plugin import React from \u0026#34;react\u0026#34;; import type { Plugin } from \u0026#34;@dmm-com/pagoda-core\u0026#34;; const minimalPlugin = { id: \u0026#34;minimal-plugin\u0026#34;, name: \u0026#34;Minimal Plugin\u0026#34;, version: \u0026#34;1.0.0\u0026#34;, routes: [ { path: \u0026#34;/ui/minimal\u0026#34;, element: React.createElement(\u0026#39;div\u0026#39;, { style: { padding: \u0026#39;20px\u0026#39; } }, React.createElement(\u0026#39;h1\u0026#39;, {}, \u0026#39;Minimal Plugin\u0026#39;), React.createElement(\u0026#39;p\u0026#39;, {}, \u0026#39;This is the simplest possible plugin.\u0026#39;) ) } ], } satisfies Plugin; export default minimalPlugin; Feature-Rich Plugin import React from \u0026#34;react\u0026#34;; import type { Plugin } from \u0026#34;@dmm-com/pagoda-core\u0026#34;; import DashboardPage from \u0026#34;./components/DashboardPage\u0026#34;; import SettingsPage from \u0026#34;./components/SettingsPage\u0026#34;; import ReportsPage from \u0026#34;./components/ReportsPage\u0026#34;; const analyticsPlugin = { id: \u0026#34;analytics-plugin\u0026#34;, name: \u0026#34;Analytics Plugin\u0026#34;, version: \u0026#34;1.2.0\u0026#34;, routes: [ { path: \u0026#34;/ui/analytics\u0026#34;, element: React.createElement(DashboardPage) }, { path: \u0026#34;/ui/analytics/settings\u0026#34;, element: React.createElement(SettingsPage) }, { path: \u0026#34;/ui/analytics/reports\u0026#34;, element: React.createElement(ReportsPage) } ], } satisfies Plugin; export default analyticsPlugin; 🔄 Changes from Legacy System Removed Features ❌ ExternalPluginLoader: No automatic plugin discovery ❌ Plugin API: No centralized API access ❌ Lifecycle hooks: No initialize/activate/deactivate methods ❌ Priority system: No plugin loading priorities ❌ Dependency management: No plugin dependencies ❌ Configuration options: No complex plugin configuration New Approach ✅ Configuration-based: Managed through plugins.config.js ✅ Type safety: Enforced with satisfies Plugin ✅ Direct integration: Components directly rendered in routes ✅ Simplicity: Minimal interface with maximum flexibility ✅ Build-time resolution: Static import generation at build time 📞 Support Getting Help Documentation: Refer to this guide and existing plugin examples Code inspection: Study pagoda-plugin-hello-world and pagoda-plugin-dashboard Console debugging: Use browser developer tools for troubleshooting Community: Engage with the development community for support Contributing Plugin examples: Share your plugin implementations Documentation improvements: Help enhance this guide Best practices: Contribute development patterns and practices Core system: Suggest improvements to the plugin architecture 🚀 Using pagoda-minimal-builder The pagoda-minimal-builder provides a complete integration environment for testing and deploying plugins.
Quick Start Navigate to pagoda-minimal-builder:
cd /path/to/airone/frontend/plugins/pagoda-minimal-builder Install dependencies:
npm install Start development server:
npm run start Access in browser:
Main app: http://localhost:3000 Hello World Plugin: http://localhost:3000/ui/hello-world Dashboard Plugin: http://localhost:3000/ui/dashboard Files Structure pagoda-minimal-builder/ ├── src/ │ ├── App.tsx # Main application entry │ └── generatedPlugins.ts # Auto-generated plugin imports ├── scripts/ │ └── generate-plugin-imports.js # Import generator ├── plugins.config.js # Plugin configuration ├── webpack.config.js # Build configuration ├── package.json # Dependencies and scripts └── README.md # Usage documentation How the Build Process Works Configuration: Edit plugins.config.js to specify plugins Auto-generation: npm run build triggers generate-plugin-imports.js Static imports: src/generatedPlugins.ts is created with import statements Bundle creation: Webpack creates dist/ui.js with all plugins included No source editing: Add/remove plugins by configuration only Development Workflow Create your plugin following the guidelines above Link locally: Use npm link for development testing Configure: Add plugin name to plugins.config.js Build \u0026amp; test: Run npm run build \u0026amp;\u0026amp; npm run start Debug: Check console logs and browser developer tools Deploy: Use generated dist/ui.js for production This simplified plugin system prioritizes ease of use and maintainability. The focus is on connecting React components to routes with minimal complexity, allowing developers to build powerful extensions without dealing with complex plugin lifecycles or APIs.
`}),e.add({id:8,href:"/release_note/",title:"Release Notes",parent:"Pagoda",content:""}),e.add({id:9,href:"/getting_started/tutorial/",title:"Tutorial",parent:"Getting Started",content:`(TBD)
`}),e.add({id:10,href:"/getting_started/development/",title:"Development",parent:"Getting Started",content:"Setup Here is the documentation to setup the development environment of Pagoda.\nInstallation of Pagoda You have to install Python3.11+ to run Pagoda like below (for the case of ubuntu).\nuser@hostname:~$ sudo apt-get update user@hostname:~$ sudo apt-get install python3 python3-pip python3-venv You have to install libraries.\nuser@hostname:~$ sudo apt-get install libldap2-dev libsasl2-dev libxmlsec1-dev libmysqlclient-dev pkg-config (for macOS)\nuser@hostname:~$ brew install libxmlsec1 mysql-client pkg-config mysql-connector-python And it\u0026rsquo;s necessary to install uv command that manages Python packages and isolates Pagoda related libraries from system use ones.\ncurl -LsSf https://astral.sh/uv/install.sh | sh Then, you can install libraries on which Pagoda depends by following after cloning this repository. But we recommand you to setup pagoda on the separated environment using virtualenv not to pollute system-wide python environment.\nuser@hostname:~$ git clone https://github.com/dmm-com/pagoda.git user@hostname:~$ cd pagoda user@hostname:~/pagoda$ uv sync Now, you have made Python environment for running Pagoda on your node. It\u0026rsquo;ll be completed to run Pagoda when you install backend middlewares(MySQL, RabbitMQ and Elasticsearch).\nThere are two options to set them up.\n(Option1: Recommended) Setting-up backends using docker-compose Check docker command has already been installed by following command.\n$ sudo docker run hello-world When docker command has not been installed, you should install Docker engine (c.f. Install Docker Engine \u0026ndash; dockerdocs)\nIt\u0026rsquo;s necessary to be able to run docker command without sudo because some script expect to run it by non-priviledged level.\n### create docker group if it\u0026#39;s necessary (it\u0026#39;s OK to run this command when group \u0026#39;docker\u0026#39; already exists) $ sudo groupadd docker ### belong current user to docker group $ sudo gpasswd -a $USER docker Then, you can make middleware nodes (MySQL, RabbitMQ and Elasticsearch) by docker compose command as below.\nuser@hostname:~/pagoda$ docker compose up -d Then, you should make user for Pagoda (internally it was named as airone) to the Elasticsearch and MySQL as below.\nfor Elasticsearch You have to create user for Pagoda and set it administrative role at the Elasticsearch by following commands.\nuser@hostname:~$ docker exec -it elasticsearch bin/elasticsearch-users useradd airone -p password user@hostname:~$ docker exec -it elasticsearch bin/elasticsearch-users roles airone --add superuser You can check whether specified user was created successfully and has proper role as below.\nuser@hostname:~$ docker exec -it elasticsearch bin/elasticsearch-users list airone : superuser for MySQL Login to the Docker node that MySQL is running by following code.\nuser@hostname:~$ docker exec -it mysql mysql -uroot Then, you should cerate database and user for Pagoda (internally called airone) in MySQL.\nmysql\u0026gt; create database airone; mysql\u0026gt; create database test_airone; mysql\u0026gt; CREATE USER \u0026#39;airone\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; mysql\u0026gt; GRANT ALL ON airone.* to airone@\u0026#39;%\u0026#39;; mysql\u0026gt; GRANT ALL ON test_airone.* to airone@\u0026#39;%\u0026#39;; (Optional) Please set the index as necessary.\nmysql\u0026gt; CREATE INDEX permission_codename_idx ON auth_permission (codename); Conguratulations, you completed to setup Pagoda execution environment.\nAfter initializing Pagoda, you can use it! Please move on to the Initialize Pagoda configuratoin.\n(Option2) Setting-up backends in manual And you have to install RabbitMQ for executing heavy processing as background task using Celery.\nuser@hostname:~$ sudo apt-get install rabbitmq-server mysql-server python-dev libmysqlclient-dev Setting-up MySQL configuration Specifying character set of database is necessary. Please add following setting in the mysqld.cnf at mysqld section.\n[mysqld] ... character-set-server = utf8mb4 Then, you should restart MySQL server to apply for this configuration.\nuser@hostname:~$ sudo service mysql restart Iincrease the number of Slave databases with the MySQL replication function.\nYou can set database slave, with like this config:\nREPLICATED_DATABASE_SLAVES = [\u0026#39;slave1\u0026#39;, \u0026#39;slave2\u0026#39;] You should cerate database and user for pagoda in MySQL.\nuser@hostname:~$ mysql -u root -h 127.0.0.1 mysql\u0026gt; create database airone; mysql\u0026gt; create database test_airone; mysql\u0026gt; CREATE USER \u0026#39;airone\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; mysql\u0026gt; GRANT ALL ON airone.* to airone@\u0026#39;%\u0026#39;; mysql\u0026gt; GRANT ALL ON test_airone.* to airone@\u0026#39;%\u0026#39;; (Optional) Please set the index as necessary.\nmysql\u0026gt; CREATE INDEX permission_codename_idx ON auth_permission (codename); Setting-up Elasticsearch You have to setup JRE for executing elasticsearch.\nuser@hostname:~$ sudo add-apt-repository ppa:linuxuprising/java user@hostname:~$ sudo apt-get update user@hostname:~$ sudo apt-get install -y oracle-java13-installer The way to install elasticsearch is quite easy like that.\nuser@hostname:~$ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.17.6-linux-x86_64.tar.gz user@hostname:~$ tar -xvf elasticsearch-7.17.6-linux-x86_64.tar.gz After installing it, you have to change configuration to accept connecting from Pagoda nodes.\n--- elasticsearch-7.17.6-linux-x86_64/config/elasticsearch.yml.old 2020-01-29 10:19:40.511687943 +0900 +++ elasticsearch-7.17.6-linux-x86_64/config/elasticsearch.yml 2020-01-29 10:41:23.103687943 +0900 @@ -52,7 +52,7 @@ # # Set the bind address to a specific IP (IPv4 or IPv6): # -#network.host: 192.168.0.1 +network.host: 0.0.0.0 # # Set a custom port for HTTP: # You should set sysctl as below because Elasticsearch requires to expand virtual memory area.\nuser@hostname:~$ sudo sysctl vm.max_map_count=262144 And you should create user and attach role in Elasticsearch.\nbin/elasticsearch-users useradd airone -p password bin/elasticsearch-users roles airone --add superuser Finally, you can run ElasticSearch service like that.\nuser@hostname:~$ elasticsearch-7.17.6-linux-x86_64/bin/elasticsearch Setting-up Email configuration This step is optional. You can skip it if you don\u0026rsquo;t use email notifications.\nPagoda supports email based notification, now it\u0026rsquo;s mainly used for password-reset. You can set email backend, with like this config:\nEMAIL_BACKEND = \u0026#39;django.core.mail.backends.smtp.EmailBackend\u0026#39; EMAIL_HOST = \u0026#39;xxx\u0026#39; EMAIL_PORT = 25 EMAIL_HOST_USER = \u0026#39;xxx\u0026#39; EMAIL_HOST_PASSWORD = \u0026#39;xxx\u0026#39; EMAIL_USE_TLS = True If you hope to just try it in your local environment, you can use stdout instead:\nEMAIL_BACKEND = \u0026#39;django.core.mail.backends.console.EmailBackend\u0026#39; Setting-up Nginx (Optional) Install Nginx by package manager like this.\nuser@hostname:~$ sudo apt-get install nginx Create Self-Signed SSL Certificate and key-pair.\nuser@hostname:~$ openssl genrsa 2048 \u0026gt; server.key user@hostname:~$ openssl req -new -key server.key \u0026gt; server.csr ... (set appropriate configuration) user@hostname:~$ openssl x509 -days 3650 -req -signkey server.key \u0026lt; server.csr \u0026gt; server.crt user@hostname:~$ sudo mkdir /etc/nginx/ssl user@hostname:~$ sudo mv server* /etc/nginx/ssl Write following configuration for Pagoda on Nginx at /etc/nginx/conf.d/pagoda.conf.\nupstream pagoda { server hostname:8080; } server { listen 443 ssl; ssl_certificate /etc/nginx/ssl/server.crt; ssl_certificate_key /etc/nginx/ssl/server.key; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Port 443; location / { rewrite ^/(.*) /$1 break; proxy_pass http://pagoda/; } access_log /var/log/nginx/pagoda.ssl.access.log combined; error_log /var/log/nginx/pagoda.ssl.error.log; # set longer to wait background processing until 300s proxy_read_timeout 300; } This includes the configuration to proxy HTTP request to Pagoda and cache static files. The static file path indicates the static directory which is in the top of Pagoda local repository. If necessary, please fix this value depending on your environment.\nInitialize Pagoda configuratoin This command makes database schema using the django Migrations, and makes default user account.\nuser@hostname:~$ cd pagoda user@hostname:~/pagoda$ tools/clear_and_initdb.sh Then, you should create an initial user to login to the Pagoda. This creates user demo.\nuser@hostname:~/pagoda$ tools/register_user.sh demo Password: ## input password of this user Succeed in register user (demo) This creates following user.\nUsername Password demo demo If you want to create an administrative user who can access all information regardless of ACL (Please refer the User-Manual(TBD)), you can do it with -s, --superuser option. This creates another user who takes privilege of this system.\nuser@hostname:~/pagoda$ tools/register_user.sh -s admin Password: ## input password of this user Succeed in register user (admin) Finally, this registers all entries which has been created in the database to the Elasticsearch.\nYou can do it just by following command. The configurations about the database to read and Elasticsearch to register are referred from airone/settings.py.\nuser@hostname:~/pagoda$ uv run python tools/initialize_es_document.py Run Pagoda You can start Pagoda as following and can browse from http://hostname:8080/\n(Please change the hostname to the appropriate one on which you installed Pagoda). e.g.\nuser@hostname:~$ cd pagoda user@hostname:~/pagoda$ uv run python manage.py runserver 0:8080 Then, you can access to the Pagoda by http://localhost:8080 from your browser.\nRun Celery In addition, you have to run Celery worker to execute background task (e.g. updating item). Please open another terminal (or screen), then run it by following command.\nuser@hostname:~$ cd pagoda user@hostname:~/pagoda$ uv run celery -A airone worker -l info Build the new UI with React /ui/ serves React-based new UI. Before you try it, you need to build ui.js:\nPreparing build environemnt Prepare to install API client npm package published on GitHub Packages. TOKEN is a your GitHub PAT. Issue your PAT with checking this doc. This requires only read:packages scope. Then, you just perform npm install as usual.\nuser@hostname:~/pagoda$ export TOKEN=\u0026#34;(FIXME: github personal access token)\u0026#34; user@hostname:~/pagoda$ cat \u0026lt;\u0026lt;EOS \u0026gt; .npmrc //npm.pkg.github.com/:_authToken=${TOKEN} EOS After installing nvm command, please install npm packages as below.\nuser@hostname:~$ nvm install 20 user@hostname:~$ cd pagoda user@hostname:~/pagoda$ npm install Building pagoda react components If you have any change on API V2, you need to run this command before you build:\nuser@hostname:~/pagoda$ npm run generate:client Build Pagoda react component by following command.\n(One time building) user@hostname:~/pagoda$ npm run build (In development) user@hostname:~/pagoda$ npm run watch API V2 client You can refer your local API client code before publishing it to GitHub Packages with following command.\nuser@hostname:~/pagoda$ npm run generate:client # generate the latest API client code on your local env user@hostname:~/pagoda$ npm run link:client # refer the latest code temporarily If you modify something in API client code, you need to publish it with the package release GitHub Actions workflow. It will be triggered by labeling release-apiv2-client to the pull request by repository owners.\nFor Custom-View Building Procedure When you want to ues Pagoda\u0026rsquo;s Custom-View, you should run following command to build react environment considering CustomView.\nuser@hostname:~/pagoda$ npm run generate:custom_client user@hostname:~/pagoda$ cp -pi ./frontend/src/App.tsx ./frontend/src/customview/CustomApp.tsx (edit CustomApp.tsx) user@hostname:~/pagoda$ npm run build:custom Auto-format user@hostname:~$ cd pagoda user@hostname:~/pagoda$ ruff format . user@hostname:~/pagoda$ ruff check --fix . user@hostname:~/pagoda$ npm run fix Test for Django processing You can run tests for processing that is run by Django and Celery, which means backend processing, as below.\nuser@hostname:~$ cd pagoda user@hostname:~/pagoda$ python manage.py test When you want to run a specific test (ModelTest.test_is_belonged_to_parent_group in the file of role/tests/test_model.py) , you can do it as below.\nuser@hostname:~/pagoda$ python manage.py test role.tests.test_model.ModelTest.test_is_belonged_to_parent_group Test for React processing You can run test for processing that is run by Browser, wihch means frontend processing as below.\nuser@hostname:~$ cd pagoda user@hostname:~/pagoda$ npm run test If you have any change on a page component, please re-build snapshots along with current implementaion as below.\nuser@hostname:~/pagoda$ npm run test:update When you want to run individual test (e.g. frontend/src/components/user/UserList.test.tsx), you can do it by following command.\nuser@hostname:~/pagoda$ npx jest -u frontend/src/components/user/UserList.test.tsx Release pagoda-core package for custom views We publish the pagoda-core package to GitHub npm Registry for custom views. When you want to release a new version of the package, create a tag with the format pagoda-core-x.y.z (e.g. pagoda-core-0.0.1). The GitHub Actions workflow will automatically build and publish the package.\nIf you hope to try building the module:\n$ npm run build:lib "}),e.add({id:11,href:"/getting_started/teckstack/",title:"Tech Stack",parent:"Getting Started",content:`Pagoda is a Single Source of Truth (SSoT) system that enables the definition of flexible data structures, relationships, and access control (ACL).
Core Architecture Pagoda comprises two UI systems:
Legacy UI: Django template-based full-stack application New UI: A combination of DRF-based REST API and React SPA Backend Django (4.x) - Full-stack web application framework
Entity-Attribute-Value (EAV) pattern for flexible data modeling Entity: Schema definitions EntityAttr: Attribute definitions with type information Entry: Data instances Attribute: Attribute values with versioning AttributeValue: Actual values with type safety Django REST Framework (3.x) - RESTful API implementation
Automatic OpenAPI spec generation (drf-spectacular) Service Layer Architecture
Clear separation between data access and business logic Dedicated services for search and data manipulation Type-safe implementations with Python type hints Frontend Legacy UI
Django template-based rendering Server-side rendering with traditional request-response cycle New UI (React SPA) (18.x)
Written in TypeScript (5.x) MUI (6.x) - UI component library State management and forms react-hook-form (7.x) zod (3.x) validation react-router (7.x) - Routing Communicates with APIv2 through a generated client Extended Features Search and Indexing Elasticsearch (7.x) - Advanced search capabilities Cross-entity and attribute search Flexible search options (exact/partial match, AND/OR, date range) Search chain for traversing entry relationships Filter options (empty/non-empty, text contains/not contains) Asynchronous result export Background Processing Celery (5.x) - Asynchronous task processing Kombu (5.x) - Messaging library Flower (1.x) - Task monitoring Data Management History Management
django-simple-history (3.x) Data Type Support
String, boolean, date, object references, etc. Development Tools Code Quality Static Analysis
ESLint (8.x) - TypeScript code analysis Prettier (3.x) - Code formatter Ruff (0.x) - Python linter and formatter mypy (1.x) - Python type checking Testing
Jest (29.x) - JavaScript testing Django standard test framework - Python testing Build Tools Frontend
Webpack (5.x) - Module bundler TypeScript (5.x) - Type-safe JavaScript openapi-generator - API type definition generation Backend
uv - Python dependency management Architecture Components Directory Structure docs/ - End-user and developer documentation frontend/ - React SPA src/apiclient/ - Wrapper for the generated API client api_v2/ - DRF APIv2 code Other paths - Django application code API Architecture APIv2 - REST API for the new UI Shares core features with the legacy UI (models, Celery tasks, other utilities) Schema as code, integration via OpenAPI spec auto-generation Advanced search API Complex search parameters Chainable search capabilities Export functionality Security and Permissions Fine-grained ACL System Flexible permission settings for each attribute data Dynamic schema definition for structured data `}),e.add({id:12,href:"/advanced/advanced_search/",title:"Advanced Search",parent:"Advanced Topics",content:`Advanced Search is a powerful feature that allows you to search across multiple entities and their attributes with various search options and filters.
Features Search Capabilities Cross-Entity Search
Search across multiple entity types simultaneously Filter results by entity type Combine search results from different entities Attribute-Based Search
Search by specific attribute values Support for various data types: Text (string, multi-line text) Numbers Dates and date ranges Boolean values Object references Search Options
Exact match or partial match AND/OR conditions between multiple search criteria Filter by attribute conditions: Empty values Non-empty values Text contains/not contains Date ranges Advanced Features Join Attrs Join Attrs enables relationship traversal in search results. Key points:
Implementation
Sequential processing: root -\u0026gt; join targets Each join triggers new Elasticsearch query Supports OBJECT and ARRAY type references Critical Considerations
Pagination Behavior
# Example: Request 100 items root_results = search(limit=100) # Returns 100 root items joined_results = join_and_filter() # May return 0-100 items next_page_starts_at = 101 # Regardless of joined result size Pagination applies to root level only Join/filter operations may reduce result size Each page may return fewer items than requested Performance Impact
N+1 query pattern with multiple joins No optimization for deep joins with filters Result Count Accuracy
Total count represents root level matches only Actual result count may be lower after joins/filters Cannot predict exact total after joins without full scan Search Chain Follow relationships between entries Search through referenced objects Chain multiple searches to traverse complex relationships Results include both direct matches and related entries Export Functionality Export search results to various formats Asynchronous processing for large result sets Progress tracking for export tasks Download exported files when ready Access Methods Web UI (Legacy) The legacy UI provides a full-featured search interface with:
Interactive search form Real-time search results Advanced filtering options Export capabilities Search chain visualization REST API (APIv2) Access Advanced Search programmatically through REST endpoints:
/api/v2/advanced_search/ - Main search endpoint /api/v2/advanced_search_chain/ - Search chain operations /api/v2/advanced_search_result/ - Export and result management Limitations and Considerations Search Limits Maximum results per query: Configurable, default is 100 entries Export size limits may apply for very large result sets Complex search chains may increase response time Performance Considerations Large result sets are processed asynchronously Complex search chains may require multiple API calls Export operations for large datasets run in the background Access Control Search results respect user permissions Attribute-level access control applies to search results Export operations require appropriate permissions Best Practices Use specific entity and attribute combinations when possible Leverage search chains for complex relationship queries Monitor export task progress for large result sets Consider pagination for large result sets in API usage For Developers Architecture Overview Core Components Service Layer
AdvancedSearchService: Main service class handling search operations Type-safe implementations using Python type hints and Pydantic models Clear separation between data access and business logic Search Engine
Elasticsearch-based implementation Custom index mapping for optimized search Support for nested objects and complex queries Configurable result window and timeout settings Data Models
Entity-Attribute-Value (EAV) pattern for flexible data modeling Versioned attribute values Type-safe attribute value storage Implementation Details Search Process Flow
Query Building: Create Elasticsearch query from search parameters Permission Checking: Apply ACL filters at entity and attribute levels Result Processing: Transform Elasticsearch results to typed models Chain Processing: Handle relationship traversal for search chains Asynchronous Operations
Celery tasks for background processing Export task management and progress tracking Configurable task queues and priorities API Integration REST Endpoints Advanced Search
Endpoint: /api/v2/advanced_search/ Supports complex search parameters Returns paginated, typed results Handles ACL filtering Search Chain
Endpoint: /api/v2/advanced_search_chain/ Manages relationship traversal Supports multiple chain steps Combines results across relationships Export Management
Endpoint: /api/v2/advanced_search_result/ Handles asynchronous export requests Provides task status monitoring Manages file downloads Response Types Strongly typed response models using Pydantic Consistent error handling Support for various result formats Development Guidelines Adding New Features Extend search capabilities through service layer Maintain type safety with Pydantic models Follow existing patterns for ACL integration Add appropriate test coverage Performance Optimization Use appropriate Elasticsearch index settings Implement efficient query patterns Consider bulk operations for large datasets Leverage caching where appropriate Testing Unit tests for service layer Integration tests for API endpoints Performance tests for search operations ACL verification tests `}),e.add({id:13,href:"/advanced/categories/",title:"Categories",parent:"Advanced Topics",content:`Categories in Pagoda help you organize and group related entities for easier navigation and management. Think of categories as customizable collections of links to your entity sets.
Features Flexible Grouping: Create categories to group related entities together Multiple Entity Association: Link multiple entities to a single category Search \u0026amp; Filter: Quickly find categories using the search functionality Priority Setting: Control the display order of categories Notes: Add descriptions or additional information to categories Managing Categories Creating a Category Click the \u0026ldquo;Create New Category\u0026rdquo; button Fill in the required information: Name: Category identifier Notes: Additional information or description Models: Select one or more entities to include Priority: Set display order (lower numbers appear first) Viewing Categories Categories are displayed in a grid layout, showing:
Category name Associated entity links Quick access to entity data Searching Categories Use the search box to filter categories by name.
Editing Categories Click the menu icon (⋮) on a category card to:
Edit category details Delete the category `}),e.add({id:14,href:"/advanced/frontend_architecture/",title:"Frontend Architecture",parent:"Advanced Topics",content:`Pagoda provides two distinct user interfaces: a modern React-based SPA (New UI) and a traditional Django template-based interface (Legacy UI). This document explains both interfaces, their features, and how to work with them.
For Users Overview New UI (React SPA) Modern, responsive single-page application Fast, client-side navigation Real-time updates and validations Consistent look and feel using Material-UI Internationalization support Legacy UI (Django Templates) Traditional server-side rendered pages Direct database operations Stable and proven interface Simpler architecture for basic operations Key Features Common Features Entity and attribute management User and group administration Access control management Advanced search capabilities History tracking Webhook management New UI Specific Features Improved response times through API-based operations Modern form handling with real-time validation Enhanced user experience with instant feedback Consistent styling across all pages Mobile-friendly responsive design Legacy UI Specific Features Direct database operations Server-side validation Traditional navigation pattern Simpler debugging process When to Use Which UI Use New UI When Working with modern browsers Requiring real-time feedback Needing mobile-friendly interface Performing complex data operations Integrating with other modern web applications Use Legacy UI When Requiring simpler, proven interface Working in environments with limited JavaScript support Needing direct database operations Performing basic CRUD operations For Developers Architecture Overview New UI Architecture Core Technologies React 18 TypeScript Material-UI (MUI) react-router for routing react-hook-form for form management zod for schema validation i18next for internationalization Directory Structure frontend/src/ ├── apiclient/ # API client wrapper ├── components/ # Reusable UI components ├── hooks/ # Custom React hooks ├── i18n/ # Internationalization ├── pages/ # Page components ├── repository/ # Data access layer ├── routes/ # Routing configuration └── services/ # Business logic Key Components API Client: Auto-generated from OpenAPI specs Form Management: react-hook-form with zod validation State Management: React hooks and context Routing: react-router with type-safe routes UI Components: Material-UI based components Legacy UI Architecture Core Technologies Django Templates jQuery (where needed) Bootstrap for styling Template Structure templates/ ├── advanced_search/ # Search interface ├── edit_entry/ # Entry management ├── list_entry/ # Entry listing ├── registration/ # User registration ├── role/ # Role management └── show_entry/ # Entry display Development Guidelines Setting Up Development Environment # Install dependencies npm install # Start development server npm run watch # Build for production npm run build:production Adding New Features New UI Development
Follow React component patterns Use TypeScript for type safety Implement responsive design Add appropriate test coverage Update API client when needed Legacy UI Development
Follow Django template patterns Maintain backwards compatibility Keep JavaScript usage minimal Test across different browsers Testing New UI Testing
Unit tests with Jest Component testing with React Testing Library E2E testing when needed i18n testing Legacy UI Testing
Django template testing Integration testing Browser compatibility testing Performance Considerations New UI Use React.memo for expensive components Implement proper code splitting Optimize bundle size Use appropriate caching strategies Legacy UI Minimize server-side processing Optimize template rendering Use appropriate caching Minimize database queries `}),e.add({id:15,href:"/advanced/google_spreadsheet_linkage/",title:"Google Spreadsheet Linkage",parent:"Advanced Topics",content:`You can make Pagoda\u0026rsquo;s items in accordance with user specified Google Spreadsheet without any effort. Those created items could be related with other ones.
How to use First of all makeing item of Google Spreadsheet Linkage configuration item. This requires following parameters.
URL of Google Spreadsheet that you want to get data from. Row number that each names are declared at. The first row number that retrieving data is set. Here is an example to get data from this example sheet.
Additionally, you can also set what kind of data type after retrieving from Spreadsheet as below.
You can call API to retrieve whole data to Pagoda from its spreadsheet. Then, you can see following result that has same data from Google Spreadsheet and related with Pagoda\u0026rsquo;s Item.
`}),e.add({id:16,href:"/categories/",title:"Categories",parent:"Pagoda",content:""}),e.add({id:17,href:"/advanced/custom_view/",title:"CustomView",parent:"Advanced Topics",content:`Overview Custom Views in Pagoda allow developers to extend the standard UI with their own React-based interfaces. This feature enables you to create specialized views that leverage Pagoda\u0026rsquo;s core functionality while providing tailored user experiences for specific use cases.
By using Custom Views, you can build interfaces that:
Present data in specialized formats Implement domain-specific workflows Integrate with Pagoda\u0026rsquo;s data model and ACL system Provide alternative navigation or interaction patterns What You Can Do with Custom Views Custom Views enable you to:
Create specialized interfaces: Build custom dashboards, data visualizations, or domain-specific tools Integrate with Pagoda\u0026rsquo;s core: Access and manipulate data using Pagoda\u0026rsquo;s data models and services Implement custom logic: Add business logic specific to your use case Extend the UI: Provide alternative ways to view and interact with your data Relationship with Pagoda Core Custom Views are built as React applications that integrate with Pagoda through the PagodaProvider component. This provider gives your Custom View access to:
Pagoda\u0026rsquo;s data models (Entity-Attribute-Value pattern) Authentication and authorization Search capabilities Other core services The Pagoda Core (@dmm-com/pagoda-core) is bundled as a library that your Custom View can import and use, allowing you to focus on building your specific interface rather than reimplementing core functionality. This package is hosted on GitHub Registry at https://github.com/dmm-com/pagoda/pkgs/npm/pagoda-core.
Note: Since @dmm-com/pagoda-core is hosted on GitHub Registry, you\u0026rsquo;ll need to configure npm to access GitHub packages. Make sure you have appropriate GitHub access and authentication set up before installing the package.
Getting Started with Custom View Development Prerequisites Node.js (v16 or later) npm (v7 or later) Basic knowledge of React and TypeScript GitHub access (for installing @dmm-com/pagoda-core from GitHub Registry) Step 1: Configure npm for GitHub Registry Before installing dependencies, configure npm to access the GitHub Registry:
# Create or edit .npmrc in your project root echo \u0026#34;@dmm-com:registry=https://npm.pkg.github.com\u0026#34; \u0026gt;\u0026gt; .npmrc # Authenticate with GitHub (you\u0026#39;ll need a personal access token with appropriate permissions) npm login --registry=https://npm.pkg.github.com --scope=@dmm-com Step 2: Clone the Example Project Start by cloning the example Custom View project:
git clone https://github.com/syucream/pagoda-customview-example cd pagoda-customview-example Step 3: Install Dependencies Install the required dependencies:
npm install Step 4: Run the Development Server Start the development server:
npm run dev This will:
Start a local development server (typically at http://localhost:5173) Enable hot module replacement for quick development Watch for file changes and automatically rebuild Step 5: Understand the Project Structure The example project demonstrates:
How to use the PagodaProvider to integrate with Pagoda Basic project structure for a Custom View How to access Pagoda\u0026rsquo;s core functionality Step 6: Build Your Custom View When building your own Custom View:
Wrap your application with PagodaProvider Use Pagoda\u0026rsquo;s core services to access and manipulate data Implement your custom UI components Add any additional business logic specific to your use case Step 7: Build for Production When ready to deploy:
npm run build This will create a production-ready build of your Custom View that can be integrated with Pagoda.
Development Notes The development server supports hot reloading - changes will be reflected immediately in the browser TypeScript errors will be shown in both the terminal and browser console The application integrates with Pagoda Core for base functionality Example Use Cases Specialized Data Visualization: Create custom charts or graphs for your data Domain-Specific Workflows: Implement guided workflows for specific business processes Alternative Navigation: Provide different ways to browse and search your data Integration with External Systems: Connect Pagoda data with other systems or APIs By leveraging Custom Views, you can extend Pagoda\u0026rsquo;s capabilities while maintaining the benefits of its core data management and ACL systems.
`}),e.add({id:18,href:"/getting_started/",title:"Getting Started",parent:"Pagoda",content:""}),e.add({id:19,href:"/",title:"Pagoda",parent:"",content:` Pagoda is a Web Application which is developed by the infrastructure division of DMM.com LLC on the purpose of managing information which is associated with on-premise equipments. This aims to be versatile and flexible for doing it.
In regard to the DMM.com, Pagoda is responsible for managing all phisical (e.g. where a Server is equipped on), logical (e.g. which IPv4/v6 addresses are binded to), managemental (e.g. accounting details for equipments), operational (e.g. who and how uses it) information. And this meets demands of individual departs departments that handle each different information and have own work styles.
We had managed those information by using a DCIM (a.k.a. Data Center Information Management) system and many spreadsheets which are related to it until then. Basic physical and logical information was managed in the DCIM. And other spreadsheets had related managemental and operational information. Sadly, there were many different similer spreadsheets that have same information.
When it comes to a equipments of Server, Data Center team has an interest in what kind of transceivers (SFP?, SFP+? or QSFP?) are installed on its ports. On the other hand, Contents Provider team is interested in storage devices on it. And Accounting team cares when they and how they were purchased. Please imagine a situation that individual teams try to handle those information by own spreadsheets. It\u0026rsquo;s nightmare to keep consistency of all those spreadsheets once its physical (this Server) would be disposed.
The original motivation of developing this software is solving this problem. If you are interested in more information about it, please check below page. (https://www.janog.gr.jp/meeting/janog45/en/program/infrabcp)
`}),e.add({id:20,href:"/getting_started/overview/",title:"Pagoda Overview",parent:"Getting Started",content:`Pagoda is an information management system with high flexibility of access control and high extensibility of data. This enables to manage information in any type of use-cases. This document describes these features.
Data model that meets with extensibility Pagoda manages informaiton by using following two type of data-structure.
Entity - has meta data (what kind of data it has and how). Entry - has actual data in conformity to an Entity which is associated with it. This page shows an example how to manage information which has complex data-structure in this system as an example of an information management system of a library. This system manages book location information (where book is arranged in), book management information (what kind book is registered) and lending information (which book is lent to whom). The following an E-R diagram that descfribes the data-model of this system.
You can easily manage those complex information by making Entities on Pagoda as below.
And by making Entries, you can register and retrieve all kind of data instances which are mentioned above.
In this way, user can handle any kind of information and information which is associated with other ones by using this simple data-structure (Entity and Entry) other than above use-case. For more information about this Pagoda\u0026rsquo;s datastructure, please see Entity and Entry page.
`}),e.add({id:21,href:"/advanced/plugin_system/",title:"Plugin System",parent:"Advanced Topics",content:`Overview Pagoda\u0026rsquo;s plugin system enables extension through completely independent external plugins using a 3-layer architecture. This system separates plugins from core functionality and provides stable extension points.
3-Layer Architecture ┌─────────────────┐ ┌──────────────────┐ ┌──────────────────┐ │ Core Layer │ │ Plugin Layer │ │Extended App Layer│ │ │ │ │ │ │ │pagoda-plugin-sdk│◄───│ External Plugin │◄───│ Pagoda │ │ │ │ │ │ │ │ • Interfaces │ │ • Plugin Logic │ │ • Bridge Impl. │ │ • Base Classes │ │ • API Endpoints │ │ • URL Integration│ │ • Common Hooks │ │ • Hook Handlers │ │ • Django Setup │ └─────────────────┘ └──────────────────┘ └──────────────────┘ Core Capabilities Plugins enable the following extensions:
API v2 Endpoints: RESTful API extensions Hook-Based Extensions: Intervention and extension of core operations Custom Business Logic: Unique processing and data manipulation Authentication \u0026amp; Authorization Integration: Utilizing Pagoda\u0026rsquo;s permission system Architecture Deep Dive Layer 1: pagoda-plugin-sdk (Core Framework) Foundation layer provided as an independent PyPI package:
# pagoda_plugin_sdk provides: from pagoda_plugin_sdk import Plugin, PluginAPIViewMixin from pagoda_plugin_sdk.models import Entity, Entry, User from pagoda_plugin_sdk.protocols import EntityProtocol, EntryProtocol, UserProtocol Features:
Distributable via PyPI Depends on Django/DRF but not on Pagoda application Type-safe Protocol definitions for host models Model injection mechanism for accessing host application data Layer 2: External Plugin (Independent Extension) Completely independent plugin that depends only on pagoda-plugin-sdk:
from pagoda_plugin_sdk import Plugin from pagoda_plugin_sdk.decorators import entry_hook class MyPlugin(Plugin): id = \u0026#34;my-plugin\u0026#34; name = \u0026#34;My Plugin\u0026#34; version = \u0026#34;1.0.0\u0026#34; django_apps = [\u0026#34;my_plugin\u0026#34;] api_v2_patterns = \u0026#34;my_plugin.api_v2.urls\u0026#34; @entry_hook(\u0026#34;after_create\u0026#34;) def log_entry_create(self, entity_name, user, entry, **kwargs): \u0026#34;\u0026#34;\u0026#34;Called after an entry is created\u0026#34;\u0026#34;\u0026#34; logger.info(f\u0026#34;Entry created: {entry.name}\u0026#34;) Layer 3: Pagoda Application (Host Application) Injects concrete model implementations into the plugin SDK:
# Pagoda injects actual models into the plugin SDK from airone.plugins.integration import plugin_integration # During initialization, real models are injected plugin_integration.initialize() # Injects Entity, Entry, User, etc. # Plugins can then access models through the SDK from pagoda_plugin_sdk.models import Entity, Entry, User Model Access through Protocols Overview Plugins access host application models through a safe injection mechanism. The SDK provides Protocol-based type definitions that ensure type safety without creating implementation dependencies.
Protocol Definitions The SDK defines type-safe protocols for all major models:
from pagoda_plugin_sdk.protocols import ( EntityProtocol, EntryProtocol, UserProtocol, EntityAttrProtocol, AttributeProtocol, AttributeValueProtocol, ) Available Protocols:
EntityProtocol - Schema definition (Entity model) EntryProtocol - Data entry (Entry model) UserProtocol - User account EntityAttrProtocol - Entity attribute definition AttributeProtocol - Entry attribute AttributeValueProtocol - Attribute value Model Injection Mechanism Models are injected by the host application during initialization:
# In Pagoda application startup from airone.plugins.integration import plugin_integration # Initialize plugin system and inject models plugin_integration.initialize() # Automatically injects real models The injection process:
Pagoda application starts Plugin system initializes Real Django models are injected into pagoda_plugin_sdk.models Plugins can safely access models through the SDK Accessing Models in Plugins Basic Model Access:
from pagoda_plugin_sdk.models import Entity, Entry, User def my_plugin_view(request): # Type-safe Entity access entities = Entity.objects.filter(is_active=True) # Type-safe Entry access entries = Entry.objects.filter(schema__name=\u0026#34;MyEntity\u0026#34;) # Access with relationships for entry in entries: entity_name = entry.schema.name # Type-safe attribute access creator = entry.created_user.username Checking Model Availability:
from pagoda_plugin_sdk import models # Check if models are initialized if models.is_initialized(): from pagoda_plugin_sdk.models import Entity entities = Entity.objects.all() else: # Handle case where plugin system is not initialized raise RuntimeError(\u0026#34;Plugin system not initialized\u0026#34;) # Get list of available models available = models.get_available_models() # [\u0026#39;Entity\u0026#39;, \u0026#39;Entry\u0026#39;, \u0026#39;User\u0026#39;, ...] Model CRUD Operations:
from pagoda_plugin_sdk.models import Entity, Entry # Create entity = Entity.objects.create( name=\u0026#34;New Entity\u0026#34;, note=\u0026#34;Created by plugin\u0026#34;, created_user=request.user ) # Read entity = Entity.objects.get(id=123) entries = Entry.objects.filter(schema=entity, is_active=True) # Update entity.note = \u0026#34;Updated by plugin\u0026#34; entity.save() # Delete (soft delete) entity.is_active = False entity.save() Using Entry-Specific Methods:
from pagoda_plugin_sdk.models import Entry # Get entry with attributes entry = Entry.objects.get(id=456) # Use Entry\u0026#39;s custom methods (defined in EntryProtocol) attrs = entry.get_attrs() # Get all attributes as dict entry.set_attrs(user=request.user, name=\u0026#34;value\u0026#34;, age=30) # Permission checking if entry.may_permitted(request.user, some_permission): # Perform operation pass Type Safety Benefits Using Protocols provides several advantages:
IDE Autocomplete: Full IntelliSense support in modern IDEs Type Checking: Static type checkers (mypy) can verify correctness No Import Errors: No circular dependency issues Documentation: Protocol definitions serve as API documentation Example with Type Hints:
from typing import List from pagoda_plugin_sdk.models import Entity, Entry from pagoda_plugin_sdk.protocols import EntityProtocol, EntryProtocol def get_entries_for_entity(entity: EntityProtocol) -\u0026gt; List[EntryProtocol]: \u0026#34;\u0026#34;\u0026#34;Get all active entries for a given entity Args: entity: Entity to query entries for Returns: List of active Entry instances \u0026#34;\u0026#34;\u0026#34; return Entry.objects.filter(schema=entity, is_active=True) Error Handling Always handle cases where models might not be available:
from pagoda_plugin_sdk.models import Entity from rest_framework.response import Response from rest_framework import status def my_view(request): try: if Entity is None: return Response( {\u0026#34;error\u0026#34;: \u0026#34;Entity model not available\u0026#34;}, status=status.HTTP_503_SERVICE_UNAVAILABLE ) entities = Entity.objects.filter(is_active=True) # Process entities... except Exception as e: return Response( {\u0026#34;error\u0026#34;: str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR ) Getting Started Prerequisites # Install pagoda-plugin-sdk from Git repository (recommended) pip install git+https://github.com/dmm-com/pagoda.git#subdirectory=plugin/sdk # Or using uv (faster) uv pip install git+https://github.com/dmm-com/pagoda.git#subdirectory=plugin/sdk # Or from local source (for SDK development) cd /path/to/pagoda/plugin/sdk pip install -e . Plugin Enablement The plugin system loads only manually specified plugins:
# Enable a single plugin export ENABLED_PLUGINS=my-plugin # Enable multiple plugins (comma-separated) export ENABLED_PLUGINS=my-plugin,another-plugin Starting Server with Plugins # Start with uv environment (recommended) ENABLED_PLUGINS=my-plugin uv run python manage.py runserver # Start with pip environment ENABLED_PLUGINS=my-plugin python manage.py runserver # Start after setting environment variable export ENABLED_PLUGINS=my-plugin python manage.py runserver Important: Only plugins explicitly specified in ENABLED_PLUGINS are loaded. If none are specified, the plugin system is disabled.
Verifying Plugin Operation Startup Logs Logs when the plugin system is operating normally:
[INFO] Initializing plugin system... [INFO] Starting plugin discovery... [INFO] Loaded external plugin: hello-world [INFO] Registered plugin: hello-world-plugin v1.0.0 [INFO] Connected Entry model signals to hook system [INFO] Pagoda bridge manager initialized successfully [INFO] Registered 2 hooks for plugin hello-world-plugin [INFO] Plugin discovery completed. Found 1 plugins. [INFO] Plugin system initialized successfully Testing Plugin APIs Sample plugin API endpoints:
# Authentication-free test endpoint (for verification) curl http://localhost:8000/api/v2/plugins/hello-world-plugin/test/ # Authentication-required endpoints curl -H \u0026#34;Authorization: Token YOUR_TOKEN\u0026#34; \\ http://localhost:8000/api/v2/plugins/hello-world-plugin/hello/ curl -H \u0026#34;Authorization: Token YOUR_TOKEN\u0026#34; \\ http://localhost:8000/api/v2/plugins/hello-world-plugin/greet/John/ curl -H \u0026#34;Authorization: Token YOUR_TOKEN\u0026#34; \\ http://localhost:8000/api/v2/plugins/hello-world-plugin/status/ Expected Response { \u0026#34;message\u0026#34;: \u0026#34;External Hello World Plugin is working via pagoda-core!\u0026#34;, \u0026#34;plugin\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;hello-world-plugin\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Hello World Plugin\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;external\u0026#34;, \u0026#34;core\u0026#34;: \u0026#34;pagoda-core\u0026#34; }, \u0026#34;test\u0026#34;: \u0026#34;no-auth\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;anonymous\u0026#34;, \u0026#34;is_authenticated\u0026#34;: false }, \u0026#34;pagoda_core_version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;timestamp\u0026#34;: \u0026#34;2025-09-15T02:09:45.658756\u0026#34; } Plugin Development Development Workflow 1. Create Plugin Structure mkdir my-pagoda-plugin cd my-pagoda-plugin # Copy from example cp -r ../plugin/examples/pagoda-hello-world-plugin/* . 2. Plugin Package Structure my-pagoda-plugin/ ├── pyproject.toml # Modern package configuration ├── Makefile # Development commands ├── README.md # Plugin documentation └── my_plugin_package/ # Main package ├── __init__.py ├── plugin.py # Plugin class definition ├── hooks.py # Hook handlers ├── apps.py # Django app configuration └── api_v2/ # API endpoints ├── __init__.py ├── urls.py # URL configuration └── views.py # API view implementation 3. pyproject.toml Configuration [project] name = \u0026#34;my-pagoda-plugin\u0026#34; version = \u0026#34;1.0.0\u0026#34; description = \u0026#34;My Pagoda Plugin\u0026#34; dependencies = [ \u0026#34;pagoda-plugin-sdk @ git+https://github.com/dmm-com/pagoda.git#subdirectory=plugin/sdk\u0026#34;, \u0026#34;Django\u0026gt;=3.2\u0026#34;, \u0026#34;djangorestframework\u0026gt;=3.12\u0026#34;, ] requires-python = \u0026#34;\u0026gt;=3.8\u0026#34; [project.entry-points.\u0026#34;pagoda.plugins\u0026#34;] my-plugin = \u0026#34;my_plugin_package.plugin:MyPlugin\u0026#34; [build-system] requires = [\u0026#34;hatchling\u0026#34;] build-backend = \u0026#34;hatchling.build\u0026#34; 4. Plugin Class Implementation from pagoda_plugin_sdk import Plugin from pagoda_plugin_sdk.decorators import entry_hook import logging logger = logging.getLogger(__name__) class MyPlugin(Plugin): # Required metadata id = \u0026#34;my-plugin\u0026#34; name = \u0026#34;My Plugin\u0026#34; version = \u0026#34;1.0.0\u0026#34; description = \u0026#34;My custom Pagoda plugin\u0026#34; author = \u0026#34;Your Name\u0026#34; # Django integration django_apps = [\u0026#34;my_plugin_package\u0026#34;] api_v2_patterns = \u0026#34;my_plugin_package.api_v2.urls\u0026#34; # Hook handlers using decorators @entry_hook(\u0026#34;after_create\u0026#34;) def log_after_create(self, entity_name, user, entry, **kwargs): \u0026#34;\u0026#34;\u0026#34;Called after an entry is created\u0026#34;\u0026#34;\u0026#34; logger.info(f\u0026#34;Entry created: {entry.name} in {entity_name}\u0026#34;) @entry_hook(\u0026#34;before_update\u0026#34;) def log_before_update(self, entity_name, user, validated_data, entry, **kwargs): \u0026#34;\u0026#34;\u0026#34;Called before an entry is updated\u0026#34;\u0026#34;\u0026#34; logger.info(f\u0026#34;Entry updating: {entry.name}\u0026#34;) return validated_data 5. API View Implementation from datetime import datetime from rest_framework.response import Response from rest_framework.permissions import AllowAny from pagoda_plugin_sdk import PluginAPIViewMixin class MyAPIView(PluginAPIViewMixin): permission_classes = [AllowAny] # For testing def get(self, request): return Response({ \u0026#34;message\u0026#34;: \u0026#34;Hello from my plugin!\u0026#34;, \u0026#34;plugin\u0026#34;: { \u0026#34;id\u0026#34;: self.plugin_id, \u0026#34;name\u0026#34;: \u0026#34;My Plugin\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34; }, \u0026#34;timestamp\u0026#34;: datetime.now().isoformat() }) Development Commands Development Make commands in plugin directory:
make help # Show available commands make dev-setup # Set up development environment make install-dev # Install in development mode make test # Run plugin tests make test-integration # Run Pagoda integration tests make build # Build distribution packages make publish-test # Publish to TestPyPI make publish # Publish to PyPI Distribution Strategies 1. PyPI Distribution # Build and publish make build make publish # Users install the plugin pip install my-pagoda-plugin 2. GitHub Releases # Create tag and release git tag v1.0.0 git push origin v1.0.0 # Users install from GitHub release pip install https://github.com/user/my-plugin/releases/download/v1.0.0/my_plugin-1.0.0-py3-none-any.whl 3. Development Installation # Development editable install pip install -e . # Development install in Poetry environment pip install -e . Asynchronous Job Tasks Plugins can define asynchronous Celery tasks that integrate with Airone\u0026rsquo;s Job system for executing long-running operations in the background.
Overview The plugin job task system enables:
Background Execution: Run time-consuming operations without blocking API responses Job UI Integration: Unified progress tracking through Airone\u0026rsquo;s Job management interface Operation Tracking: Audit trail of who executed what and when Status Management: Automatic handling of job lifecycle states Operation ID Allocation Each job task requires a unique operation ID for tracking and execution.
ID Range Allocation:
1-99: Core operations (reserved for Airone core) 100-199: custom_view operations (reserved for legacy custom views) 200-9999: Plugin operations (available for plugin use) 10000+: Reserved for future use Configuration:
Operation ID ranges are configured in Airone settings or via environment variable:
# In airone/settings_common.py or as environment variable PLUGIN_OPERATION_ID_CONFIG = { \u0026#34;hello-world\u0026#34;: (5000, 5099), # Plugin ID: (range_start, range_end) \u0026#34;my-plugin\u0026#34;: (6000, 6099), } Each plugin is allocated a range (e.g., 100 IDs from 5000 to 5099). Task operations use offsets within this range:
# Actual operation_id = range_start + offset # Example: hello-world plugin with offset 0 → operation_id = 5000 Implementing Plugin Tasks Plugin job tasks follow a four-step implementation pattern:
1. Define Operation Offsets (config.py) Create a configuration file defining task offsets and metadata:
# my_plugin/config.py import enum from airone.lib.plugin_task import PluginTaskConfig class MyPluginOperation(int, enum.Enum): \u0026#34;\u0026#34;\u0026#34;Operation offsets for my-plugin tasks\u0026#34;\u0026#34;\u0026#34; TASK_A = 0 # offset within allocated range TASK_B = 1 TASK_C = 2 PLUGIN_TASK_CONFIG = PluginTaskConfig( plugin_id=\u0026#34;my-plugin\u0026#34;, module_path=\u0026#34;my_plugin.tasks\u0026#34;, tasks={ # \u0026#34;operation_name\u0026#34;: (offset, \u0026#34;function_name\u0026#34;) \u0026#34;task_a\u0026#34;: (MyPluginOperation.TASK_A, \u0026#34;task_a\u0026#34;), \u0026#34;task_b\u0026#34;: (MyPluginOperation.TASK_B, \u0026#34;task_b\u0026#34;), }, # Optional: specify task behavior hidden_operations=[\u0026#34;task_b\u0026#34;], # Hide from UI cancelable_operations=[\u0026#34;task_a\u0026#34;], # Allow user cancellation ) 2. Implement Celery Task (tasks.py) Create the task implementation with proper decorators:
# my_plugin/tasks.py import logging from airone.celery import app from airone.lib.plugin_task import register_plugin_job_task from job.models import Job, JobStatus from my_plugin.config import MyPluginOperation logger = logging.getLogger(__name__) @register_plugin_job_task(MyPluginOperation.TASK_A) @app.task(bind=True) def task_a(self, job_id: int): \u0026#34;\u0026#34;\u0026#34;Example job task implementation\u0026#34;\u0026#34;\u0026#34; try: job = Job.objects.get(id=job_id) except Job.DoesNotExist: logger.error(f\u0026#34;Job {job_id} not found\u0026#34;) return # Check if job was canceled by user if job.is_canceled(): logger.info(f\u0026#34;Job {job_id} was canceled\u0026#34;) return # Check if job is ready to proceed if not job.proceed_if_ready(): logger.warning(f\u0026#34;Job {job_id} is not ready\u0026#34;) return # Update status to processing job.update(JobStatus.PROCESSING) try: # Your long-running task logic here params = job.params # Access job parameters logger.info(f\u0026#34;Processing job {job_id} with params: {params}\u0026#34;) # Example: process data import time time.sleep(10) # Simulate long operation # Update status to done job.update(JobStatus.DONE) logger.info(f\u0026#34;Job {job_id} completed successfully\u0026#34;) except Exception as e: logger.error(f\u0026#34;Job {job_id} failed: {e}\u0026#34;, exc_info=True) job.update(JobStatus.ERROR) Key Implementation Points:
Double Decorator: Use both @register_plugin_job_task(offset) and @app.task(bind=True) Status Checks: Always check is_canceled() and proceed_if_ready() Status Updates: Update job status to PROCESSING, DONE, or ERROR Error Handling: Catch exceptions and update status to ERROR 3. Register in AppConfig (apps.py) Register the plugin\u0026rsquo;s task configuration during Django initialization:
# my_plugin/apps.py import logging from django.apps import AppConfig from airone.lib.plugin_task import PluginTaskRegistry logger = logging.getLogger(__name__) class MyPluginConfig(AppConfig): default_auto_field = \u0026#34;django.db.models.BigAutoField\u0026#34; name = \u0026#34;my_plugin\u0026#34; def ready(self): \u0026#34;\u0026#34;\u0026#34;Called when Django app is ready\u0026#34;\u0026#34;\u0026#34; from my_plugin.config import PLUGIN_TASK_CONFIG # Register plugin tasks with global registry PluginTaskRegistry.register(PLUGIN_TASK_CONFIG) logger.info(\u0026#34;Plugin tasks registered successfully\u0026#34;) 4. Trigger Job from API (api_v2/views.py) Create an API endpoint to trigger the job:
# my_plugin/api_v2/views.py from rest_framework.response import Response from rest_framework import status from pagoda_plugin_sdk import PluginAPIViewMixin from airone.lib.plugin_task import PluginTaskRegistry from job.models import Job class TaskView(PluginAPIViewMixin): def post(self, request): \u0026#34;\u0026#34;\u0026#34;Trigger a background job task\u0026#34;\u0026#34;\u0026#34; try: # Get operation_id from registry operation_id = PluginTaskRegistry.get_operation_id( \u0026#34;my-plugin\u0026#34;, \u0026#34;task_a\u0026#34; ) # Create new job job = Job._create_new_job( user=request.user, target=None, # Optional: ACL object for permission checks operation=operation_id, text=\u0026#34;Task A Processing\u0026#34;, params={ \u0026#34;input_data\u0026#34;: request.data.get(\u0026#34;input\u0026#34;), \u0026#34;options\u0026#34;: request.data.get(\u0026#34;options\u0026#34;, {}), }, ) # Queue job for execution job.run() return Response({ \u0026#34;message\u0026#34;: \u0026#34;Task queued successfully\u0026#34;, \u0026#34;job_id\u0026#34;: job.id, }, status=status.HTTP_201_CREATED) except Exception as e: return Response( {\u0026#34;error\u0026#34;: str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR ) Job Lifecycle Jobs follow a standard lifecycle with automatic state transitions:
API Request ↓ Job._create_new_job() ↓ (status = PREPARING) ↓ job.run() ↓ (Celery task queued) ↓ Task Handler executes ↓ (status = PROCESSING) ↓ Business logic execution ↓ ├─ Success → status = DONE └─ Failure → status = ERROR User can cancel → status = CANCELED Job Status Values:
PREPARING: Job created, waiting to start PROCESSING: Task is currently executing DONE: Task completed successfully ERROR: Task failed with an error CANCELED: User canceled the job Best Practices 1. Always Check Job Status @app.task(bind=True) def my_task(self, job_id: int): job = Job.objects.get(id=job_id) # Check if user canceled if job.is_canceled(): return # Check if dependencies are met if not job.proceed_if_ready(): return # Proceed with task... 2. Update Status Appropriately # When starting work job.update(JobStatus.PROCESSING) # When successful job.update(JobStatus.DONE) # When failed job.update(JobStatus.ERROR) 3. Handle Errors Gracefully try: # Task logic result = perform_operation() job.update(JobStatus.DONE) except SpecificException as e: logger.error(f\u0026#34;Specific error: {e}\u0026#34;) job.update(JobStatus.ERROR) except Exception as e: logger.error(f\u0026#34;Unexpected error: {e}\u0026#34;, exc_info=True) job.update(JobStatus.ERROR) 4. Use Meaningful Job Text # Good: Descriptive job text job = Job._create_new_job( user=request.user, operation=operation_id, text=f\u0026#34;Processing {entity_name} export ({len(entries)} entries)\u0026#34;, ) # Bad: Generic text job = Job._create_new_job( user=request.user, operation=operation_id, text=\u0026#34;Processing\u0026#34;, ) 5. Test with Celery Worker Always test plugin tasks with a running Celery worker:
# Terminal 1: Start Celery worker poetry run celery -A airone worker -l info # Terminal 2: Start Django server ENABLED_PLUGINS=my-plugin python manage.py runserver # Terminal 3: Trigger task curl -X POST http://localhost:8000/api/v2/plugins/my-plugin/task/ \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -H \u0026#34;Authorization: Token YOUR_TOKEN\u0026#34; \\ -d \u0026#39;{\u0026#34;input\u0026#34;: \u0026#34;test data\u0026#34;}\u0026#39; Validation at Startup Django automatically validates all plugin operation IDs during startup:
# In airone/job/apps.py class JobConfig(AppConfig): def ready(self): PluginTaskRegistry.validate_all() Validation Checks:
Range Conflicts: Ensures no overlap between plugin ID ranges Offset Bounds: Verifies all offsets are within allocated range Missing Registration: Detects plugins without registry entries Example Validation Error:
django.core.exceptions.ImproperlyConfigured: Plugin \u0026#39;my-plugin\u0026#39; operation \u0026#39;task_a\u0026#39; with offset 150 exceeds allocated range (6000, 6099). Maximum offset is 99. If validation fails, Django will not start, preventing deployment of misconfigured plugins.
Checking Job Status Users can check job status through the standard Job API:
# Get job details curl http://localhost:8000/api/v2/jobs/\u0026lt;job_id\u0026gt;/ \\ -H \u0026#34;Authorization: Token YOUR_TOKEN\u0026#34; Response:
{ \u0026#34;id\u0026#34;: 123, \u0026#34;user\u0026#34;: {\u0026#34;id\u0026#34;: 1, \u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;}, \u0026#34;text\u0026#34;: \u0026#34;Task A Processing\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;DONE\u0026#34;, \u0026#34;operation\u0026#34;: 6000, \u0026#34;created_at\u0026#34;: \u0026#34;2025-11-01T12:00:00Z\u0026#34;, \u0026#34;updated_at\u0026#34;: \u0026#34;2025-11-01T12:00:10Z\u0026#34; } Complete Example For a complete working example, see the hello-world-plugin implementation at:
plugin/examples/pagoda-hello-world-plugin/ ├── pagoda_hello_world_plugin/ │ ├── config.py # Operation offset definitions │ ├── tasks.py # Celery task implementations │ ├── apps.py # Task registry registration │ └── api_v2/ │ └── views.py # API endpoint for job creation The example demonstrates:
Operation offset enumeration Task implementation with proper decorators Registry registration in AppConfig API endpoint for triggering jobs Status checking and error handling Sample Plugin Reference Available Example A complete sample plugin is available at plugin/examples/pagoda-hello-world-plugin/:
Endpoints:
GET /api/v2/plugins/hello-world-plugin/test/ - Authentication-free test GET /api/v2/plugins/hello-world-plugin/hello/ - Basic Hello API POST /api/v2/plugins/hello-world-plugin/hello/ - Custom message API GET /api/v2/plugins/hello-world-plugin/greet/\u0026lt;name\u0026gt;/ - Personalized greeting GET /api/v2/plugins/hello-world-plugin/status/ - Plugin status GET /api/v2/plugins/hello-world-plugin/entities/ - List all entities (demonstrates model access) GET /api/v2/plugins/hello-world-plugin/entities/\u0026lt;id\u0026gt;/ - Get entity details GET /api/v2/plugins/hello-world-plugin/entries/ - List entries with filtering GET /api/v2/plugins/hello-world-plugin/entries/\u0026lt;id\u0026gt;/ - Get entry with attributes Model Access Examples:
The sample plugin demonstrates how to access host application models:
from pagoda_plugin_sdk import PluginAPIViewMixin from pagoda_plugin_sdk.models import Entity, Entry class EntityListView(PluginAPIViewMixin): def get(self, request): # Type-safe entity access entities = Entity.objects.filter(is_active=True) entity_list = [ { \u0026#34;id\u0026#34;: entity.id, \u0026#34;name\u0026#34;: entity.name, \u0026#34;note\u0026#34;: entity.note, } for entity in entities ] return Response({\u0026#34;entities\u0026#34;: entity_list}) Configuration Environment Variables Variable Default Description ENABLED_PLUGINS [] List of plugins to enable (comma-separated) Django Settings Integration # airone/settings_common.py ENABLED_PLUGINS = env.list(\u0026#34;ENABLED_PLUGINS\u0026#34;, default=[]) # Plugin system is automatically enabled if any plugins are specified PLUGINS_ENABLED = bool(ENABLED_PLUGINS) # Plugin apps are dynamically added to INSTALLED_APPS if PLUGINS_ENABLED: INSTALLED_APPS.extend(plugin_integration.get_installed_apps()) Manual Plugin Control The plugin system adopts explicit control:
No Automatic Discovery: Does not automatically load available plugins Explicit Specification: Only loads plugins specified in ENABLED_PLUGINS Security: Prevents loading of unintended plugins Controllability: Easy plugin control in development and production environments Troubleshooting Common Issues and Solutions 1. 404 Error on Plugin Endpoints Symptoms: curl http://localhost:8000/api/v2/plugins/my-plugin/test/ returns 404
Causes and Solutions:
# Cause 1: Plugin not specified ❌ python manage.py runserver ✅ ENABLED_PLUGINS=my-plugin python manage.py runserver # Cause 2: Plugin not installed ❌ pip install -e plugin_examples/my-plugin/ ✅ cd plugin_examples/my-plugin/ \u0026amp;\u0026amp; pip install -e . # Cause 3: Incorrect Entry points path ❌ \u0026#39;my-plugin = my_plugin:MyPlugin\u0026#39; ✅ \u0026#39;my-plugin = my_plugin.plugin:MyPlugin\u0026#39; # Cause 4: Incorrect Entry points group name ❌ [project.entry-points.\u0026#34;airone.plugins\u0026#34;] ✅ [project.entry-points.\u0026#34;pagoda.plugins\u0026#34;] 2. Plugin Discovery Failures Log Example:
[ERROR] Failed to load external plugin my-plugin: No module named \u0026#39;my_plugin\u0026#39; [INFO] Plugin discovery completed. Found 0 plugins. Resolution Steps:
Check Entry points: python -c \u0026#34; import pkg_resources for ep in pkg_resources.iter_entry_points(\u0026#39;pagoda.plugins\u0026#39;): print(f\u0026#39;{ep.name} -\u0026gt; {ep.module_name}:{ep.attrs[0]}\u0026#39;) try: plugin_class = ep.load() print(f\u0026#39;✓ Load successful: {plugin_class}\u0026#39;) except Exception as e: print(f\u0026#39;✗ Load failed: {e}\u0026#39;) \u0026#34; Reinstall Plugin: cd my-plugin/ pip uninstall -y my-plugin rm -rf build/ dist/ *.egg-info/ pip install -e . Check Path and Module: python -c \u0026#34; import sys sys.path.insert(0, \u0026#39;plugin_examples/my-plugin\u0026#39;) from my_plugin.plugin import MyPlugin print(f\u0026#39;✓ Direct import works: {MyPlugin().name}\u0026#39;) \u0026#34; 3. Hook Execution Errors Log Example:
[ERROR] Hook entry.after_create failed: missing required arguments Solution: Implement correct hook handler signature with decorator
# ❌ Wrong (missing decorator) def log_after_create(self, entity_name, user, entry, **kwargs): pass # ❌ Wrong (incorrect signature) @entry_hook(\u0026#34;after_create\u0026#34;) def log_after_create(user, entry): pass # ✅ Correct @entry_hook(\u0026#34;after_create\u0026#34;) def log_after_create(self, entity_name, user, entry, **kwargs): \u0026#34;\u0026#34;\u0026#34; entity_name: Name of the entity user: User who created the entry entry: The created Entry instance **kwargs: Additional context \u0026#34;\u0026#34;\u0026#34; logger.info(f\u0026#34;New entry created: {entry.name} in {entity_name}\u0026#34;) 4. Plugin Development Environment Issues Development with Poetry:
# If pagoda-core is not found cd pagoda-core/ make install-dev # Install plugin for development cd ../plugin_examples/my-plugin/ pip install -e . # Run integration tests make test-integration Debug Commands # Check plugin status ENABLED_PLUGINS=hello-world python manage.py shell -c \u0026#34; from airone.plugins.integration import plugin_integration plugin_integration.initialize() print(f\u0026#39;Plugins: {plugin_integration.get_enabled_plugin_count()}\u0026#39;) for plugin in plugin_integration.get_enabled_plugins(): print(f\u0026#39; - {plugin.name} ({plugin.id}) v{plugin.version}\u0026#39;) \u0026#34; # Test URL resolution python -c \u0026#34; import django django.setup() from django.urls import get_resolver resolver = get_resolver() match = resolver.resolve(\u0026#39;/api/v2/plugins/hello-world-plugin/test/\u0026#39;) print(f\u0026#39;✓ URL resolved: {match.func}\u0026#39;) \u0026#34; # Get hook statistics python -c \u0026#34; from airone.plugins.bridge_manager import bridge_manager bridge_manager.initialize() stats = bridge_manager.hooks.get_hook_statistics() print(f\u0026#39;Total hooks: {stats[\\\u0026#34;total_hooks\\\u0026#34;]}\u0026#39;) print(f\u0026#39;Registered hooks: {stats[\\\u0026#34;registered_hooks\\\u0026#34;]}\u0026#39;) \u0026#34; Architecture Details Plugin Discovery Process 1. External Plugin Discovery (Entry Points) ├─ pkg_resources.iter_entry_points(\u0026#39;pagoda.plugins\u0026#39;) ├─ Load plugin class from entry point └─ Register with plugin_registry 2. Example Plugin Discovery (Directory Scan) ├─ Scan plugin_examples/ directory ├─ Import plugin.py from each plugin directory └─ Register discovered plugin classes 3. Plugin Integration ├─ Django Apps → INSTALLED_APPS integration ├─ URL Patterns → api_v2/urls.py integration ├─ Hook Registration → bridge_manager.hooks └─ Bridge System Initialization Hook System Architecture The plugin system provides a comprehensive hook system with 17 standard hooks organized into four categories:
Available Hook Types 1. Entry Lifecycle Hooks
entry.before_create - Called before an entry is created entry.after_create - Called after an entry is created entry.before_update - Called before an entry is updated entry.after_update - Called after an entry is updated entry.before_delete - Called before an entry is deleted entry.before_restore - Called before an entry is restored entry.after_restore - Called after an entry is restored 2. Entity Lifecycle Hooks
entity.before_create - Called before an entity is created entity.after_create - Called after an entity is created entity.before_update - Called before an entity is updated entity.after_update - Called after an entity is updated 3. Validation Hooks
entry.validate - Custom validation for entry creation/update 4. Data Access Hooks
entry.get_attrs - Modify entry attributes before returning to client entity.get_attrs - Modify entity attributes before returning to client Hook Decorators The plugin SDK provides four decorators for registering hook handlers:
1. @entry_hook(hook_name, entity=None, priority=100)
For Entry lifecycle hooks. Supports entity-specific filtering.
from pagoda_plugin_sdk.decorators import entry_hook class MyPlugin(Plugin): # Apply to all entities @entry_hook(\u0026#34;after_create\u0026#34;) def log_all_entries(self, entity_name, user, entry, **kwargs): logger.info(f\u0026#34;Entry created: {entry.name}\u0026#34;) # Apply only to specific entity @entry_hook(\u0026#34;after_create\u0026#34;, entity=\u0026#34;customer\u0026#34;) def log_customer_only(self, entity_name, user, entry, **kwargs): logger.info(f\u0026#34;Customer entry created: {entry.name}\u0026#34;) 2. @entity_hook(hook_name, priority=100)
For Entity lifecycle hooks.
from pagoda_plugin_sdk.decorators import entity_hook class MyPlugin(Plugin): @entity_hook(\u0026#34;after_create\u0026#34;) def log_entity_create(self, user, entity, **kwargs): logger.info(f\u0026#34;Entity created: {entity.name}\u0026#34;) 3. @validation_hook(priority=100)
For entry validation (entry.validate hook).
from pagoda_plugin_sdk.decorators import validation_hook class MyPlugin(Plugin): @validation_hook() def validate_entry(self, user, schema_name, name, attrs, instance, **kwargs): if \u0026#34;forbidden\u0026#34; in name.lower(): raise ValueError(\u0026#34;Name cannot contain \u0026#39;forbidden\u0026#39;\u0026#34;) 4. @get_attrs_hook(target, priority=100)
For data access hooks. Target must be either \u0026ldquo;entry\u0026rdquo; or \u0026ldquo;entity\u0026rdquo;.
from pagoda_plugin_sdk.decorators import get_attrs_hook class MyPlugin(Plugin): @get_attrs_hook(\u0026#34;entry\u0026#34;) def modify_entry_attrs(self, entry, attrinfo, is_retrieve, **kwargs): # Add custom field for attr in attrinfo: attr[\u0026#34;custom_flag\u0026#34;] = True return attrinfo @get_attrs_hook(\u0026#34;entity\u0026#34;) def modify_entity_attrs(self, entity, attrinfo, **kwargs): return attrinfo Entity Filtering Entry hooks support entity-specific filtering using the entity parameter:
class MyPlugin(Plugin): # Runs only for \u0026#34;product\u0026#34; entity @entry_hook(\u0026#34;after_create\u0026#34;, entity=\u0026#34;product\u0026#34;) def handle_product_create(self, entity_name, user, entry, **kwargs): # Only called when a product entry is created pass # Runs for all entities @entry_hook(\u0026#34;after_create\u0026#34;) def handle_any_create(self, entity_name, user, entry, **kwargs): # Called for all entry creations pass When both entity-specific and generic hooks are registered, both will be executed in priority order.
Hook Priority System Hooks are executed in priority order (lower number = higher priority, default is 100):
class MyPlugin(Plugin): # Runs first (priority 50) @entry_hook(\u0026#34;after_create\u0026#34;, priority=50) def first_handler(self, entity_name, user, entry, **kwargs): logger.info(\u0026#34;Runs first\u0026#34;) # Runs second (default priority 100) @entry_hook(\u0026#34;after_create\u0026#34;) def second_handler(self, entity_name, user, entry, **kwargs): logger.info(\u0026#34;Runs second\u0026#34;) # Runs last (priority 150) @entry_hook(\u0026#34;after_create\u0026#34;, priority=150) def third_handler(self, entity_name, user, entry, **kwargs): logger.info(\u0026#34;Runs last\u0026#34;) This is useful for ensuring proper execution order when multiple plugins handle the same hook.
Hook Signatures Each hook type has a specific signature:
Entry Lifecycle Hooks:
def handler(self, entity_name: str, user: User, entry: Entry, **kwargs) -\u0026gt; None: # For after_create, after_update, after_delete, after_restore pass def handler(self, entity_name: str, user: User, validated_data: dict, **kwargs) -\u0026gt; dict: # For before_create - can modify data return validated_data def handler(self, entity_name: str, user: User, validated_data: dict, entry: Entry, **kwargs) -\u0026gt; dict: # For before_update - can modify data return validated_data def handler(self, entity_name: str, user: User, entry: Entry, **kwargs) -\u0026gt; None: # For before_delete, before_restore pass Entity Lifecycle Hooks:
def handler(self, user: User, entity: Entity, **kwargs) -\u0026gt; None: # For after_create, after_update pass def handler(self, user: User, validated_data: dict, **kwargs) -\u0026gt; dict: # For before_create - can modify data return validated_data def handler(self, user: User, validated_data: dict, entity: Entity, **kwargs) -\u0026gt; dict: # For before_update - can modify data return validated_data Validation Hook:
def handler(self, user: User, schema_name: str, name: str, attrs: list, instance: Optional[Entry], **kwargs) -\u0026gt; None: # Raise ValueError or ValidationError to reject if invalid_condition: raise ValueError(\u0026#34;Validation error message\u0026#34;) Data Access Hooks:
def handler(self, entry: Entry, attrinfo: list, is_retrieve: bool, **kwargs) -\u0026gt; list: # For entry.get_attrs - must return modified attrinfo return attrinfo def handler(self, entity: Entity, attrinfo: list, **kwargs) -\u0026gt; list: # For entity.get_attrs - must return modified attrinfo return attrinfo Backward Compatibility The hook system maintains backward compatibility with the legacy custom_view system through hook name aliases:
# Legacy custom_view hook names are automatically mapped to standard names HOOK_ALIASES = { \u0026#34;before_create_entry_v2\u0026#34;: \u0026#34;entry.before_create\u0026#34;, \u0026#34;after_create_entry_v2\u0026#34;: \u0026#34;entry.after_create\u0026#34;, \u0026#34;before_update_entry_v2\u0026#34;: \u0026#34;entry.before_update\u0026#34;, \u0026#34;after_update_entry_v2\u0026#34;: \u0026#34;entry.after_update\u0026#34;, \u0026#34;before_delete_entry_v2\u0026#34;: \u0026#34;entry.before_delete\u0026#34;, \u0026#34;validate_entry\u0026#34;: \u0026#34;entry.validate\u0026#34;, \u0026#34;get_entry_attr\u0026#34;: \u0026#34;entry.get_attrs\u0026#34;, \u0026#34;get_entity_attr\u0026#34;: \u0026#34;entity.get_attrs\u0026#34;, # ... and more } This allows existing custom_view implementations to work with the new plugin system without modification.
Hook Execution Implementation # Pagoda Hook Manager implementation class HookManager: def execute_hook(self, hook_name, *args, entity_name=None, **kwargs): # 1. Normalize hook name (handle aliases) # 2. Get all registered handlers # 3. Filter by entity if specified # 4. Sort by priority # 5. Execute each handler with error isolation # 6. Collect and return results Key features:
Error Isolation: One plugin\u0026rsquo;s failure doesn\u0026rsquo;t affect others Priority Ordering: Handlers execute in priority order Entity Filtering: Entity-specific hooks run only for matching entities Flexible Signatures: Different hook types have different signatures Model Injection Implementation The host application (Pagoda) injects concrete model implementations into the plugin SDK during initialization. This allows plugins to access Pagoda\u0026rsquo;s data models without creating direct dependencies.
Injected Models The following six models are automatically injected:
Entity - Schema definition (from entity.models.Entity) EntityAttr - Entity attribute definition (from entity.models.EntityAttr) Entry - Data entry (from entry.models.Entry) Attribute - Entry attribute (from entry.models.Attribute) AttributeValue - Attribute value (from entry.models.AttributeValue) User - User account (from user.models.User) Injection Process # airone/plugins/integration.py class PluginIntegration: def _inject_models(self): \u0026#34;\u0026#34;\u0026#34;Inject real models into the plugin SDK\u0026#34;\u0026#34;\u0026#34; try: # Import real models from Pagoda import pagoda_plugin_sdk.models as sdk_models from entity.models import Entity, EntityAttr from entry.models import Entry, Attribute, AttributeValue from user.models import User # Inject real models into SDK namespace sdk_models.Entity = Entity sdk_models.Entry = Entry sdk_models.User = User sdk_models.AttributeValue = AttributeValue sdk_models.EntityAttr = EntityAttr sdk_models.Attribute = Attribute logger.info(\u0026#34;Successfully injected models into plugin SDK\u0026#34;) except ImportError as e: logger.error(f\u0026#34;Failed to inject models into plugin SDK: {e}\u0026#34;) raise Initialization Sequence 1. Pagoda Application Startup └─ settings_common.py loads ENABLED_PLUGINS from environment 2. Plugin System Initialization ├─ PluginIntegration.initialize() is called ├─ discover_plugins() finds and registers plugins └─ _inject_models() injects real models into SDK 3. Plugin Access └─ Plugins can now safely import and use models Using Injected Models in Plugins # In plugin code from pagoda_plugin_sdk.models import Entity, Entry, User class MyPlugin(Plugin): @entry_hook(\u0026#34;after_create\u0026#34;) def handle_entry_create(self, entity_name, user, entry, **kwargs): # Direct access to model methods entity = entry.schema # Access related Entity creator = entry.created_user # Access related User attrs = entry.get_attrs() # Call Entry methods # Query operations all_entries = Entry.objects.filter(schema=entity) active_users = User.objects.filter(is_active=True) Type Safety with Protocols The SDK provides Protocol definitions for type checking without creating implementation dependencies:
from pagoda_plugin_sdk.protocols import ( EntityProtocol, EntryProtocol, UserProtocol, EntityAttrProtocol, AttributeProtocol, AttributeValueProtocol, ) def process_entry(entry: EntryProtocol) -\u0026gt; dict: \u0026#34;\u0026#34;\u0026#34;Type-safe entry processing with IDE support\u0026#34;\u0026#34;\u0026#34; return { \u0026#34;id\u0026#34;: entry.id, \u0026#34;name\u0026#34;: entry.name, \u0026#34;schema\u0026#34;: entry.schema.name, # Full IntelliSense support } Checking Model Availability Always check if models are available before using them:
from pagoda_plugin_sdk import models from pagoda_plugin_sdk.models import Entity def safe_operation(): # Check if plugin system is initialized if not models.is_initialized(): raise RuntimeError(\u0026#34;Plugin system not initialized\u0026#34;) # Check specific model if Entity is None: raise RuntimeError(\u0026#34;Entity model not available\u0026#34;) # Safe to proceed entities = Entity.objects.all() This injection mechanism ensures that plugins remain independent of Pagoda\u0026rsquo;s implementation while still having full access to its data models.
Best Practices 1. Plugin Development Version Pinning: Ensure compatibility with pagoda-core\u0026gt;=1.0.0,\u0026lt;2.0.0 Testing: Implement both unit tests and Pagoda integration tests Documentation: Include README and API specifications Error Handling: Implement proper exception handling in hooks and APIs Security: Implement proper authentication and authorization 2. Distribution Semantic Versioning: Use appropriate major.minor.patch versioning Changelog: Maintain release notes and change history Compatibility: Clearly specify supported Pagoda/pagoda-plugin-sdk versions Dependencies: Keep dependencies to a minimum 3. Production Deployment Environment Isolation: Isolate virtual environments per plugin Monitoring: Monitor plugin error logs Rollback Strategy: Prepare procedures for disabling plugins Performance: Evaluate performance impact of hook processing This 3-layer architecture realizes a plugin system completely independent from Pagoda. Plugin developers can create safe and reusable plugins depending only on pagoda-plugin-sdk.
`}),e.add({id:22,href:"/tags/",title:"Tags",parent:"Pagoda",content:""})})()