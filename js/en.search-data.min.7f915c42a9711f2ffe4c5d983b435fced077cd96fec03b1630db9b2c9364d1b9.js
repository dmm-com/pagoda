"use strict";(function(){const t={};t.doc={id:"id",field:["title","content"],store:["title","href","parent"]};const e=FlexSearch.create(t);window.geekdocSearchIndex=e,e.add({id:0,href:"/advanced/",title:"Advanced Topics",parent:"Pagoda",content:""}),e.add({id:1,href:"/release_note/CHANGELOG/",title:"Changelog",parent:"Release Notes",content:"in development Fixed Fixed a bug not to change referral values when entity was edited v2.4.0 Changed Change implementation about editing Entity to disable to edit type of EntityAttr v2.3.1 Fixed Fixed a problem that date value won\u0026rsquo;t be shown at advanced search result v2.3.0 Added Added new AttributeType array group that could contain multiple Group referral in an Attribute value v2.2.0 Added Added a method in Entry to get an AttributeValue from Entry object with a small number of SQL v2.1.0 Added Added an API endpoint that returns change history of specific entry\u0026rsquo;s attribute. Added a feature to be able to confirm job of deleting entry from Job list view (#10) v2.0.1 Fixed Fixed a bug that mandatory parameter was able to be updated with empty value by specifying \u0026lsquo;- NOT SET -\u0026rsquo; value (#20) v2.0.0 Added Added a new optional authentication feature which is able to authenticate user with LDAP server (#6) "}),e.add({id:2,href:"/getting_started/installation/",title:"Installation and Configuration",parent:"Getting Started",content:`(TBD)
`}),e.add({id:3,href:"/posts/",title:"News",parent:"Pagoda",content:""}),e.add({id:4,href:"/release_note/",title:"Release Notes",parent:"Pagoda",content:""}),e.add({id:5,href:"/getting_started/tutorial/",title:"Tutorial",parent:"Getting Started",content:`(TBD)
`}),e.add({id:6,href:"/getting_started/development/",title:"Development",parent:"Getting Started",content:"Setup Here is the documentation to setup the development environment of Pagoda.\nInstallation of Pagoda You have to install Python3.11+ to run Pagoda like below (for the case of ubuntu).\nuser@hostname:~$ sudo apt-get update user@hostname:~$ sudo apt-get install python3 python3-pip python3-venv You have to install libraries.\nuser@hostname:~$ sudo apt-get install libldap2-dev libsasl2-dev libxmlsec1-dev libmysqlclient-dev pkg-config (for macOS)\nuser@hostname:~$ brew install libxmlsec1 mysql-client pkg-config mysql-connector-python Then, you can install libraries on which Pagoda depends by following after cloning this repository. But we recommand you to setup pagoda on the separated environment using virtualenv not to pollute system-wide python environment.\nuser@hostname:~$ git clone https://github.com/dmm-com/pagoda.git user@hostname:~$ cd pagoda user@hostname:~/pagoda$ python3 -m venv virtualenv user@hostname:~/pagoda$ source virtualenv/bin/activate (virtualenv) user@hostname:~/pagoda$ pip install pip --upgrade (virtualenv) user@hostname:~/pagoda$ pip install poetry (virtualenv) user@hostname:~/pagoda$ poetry install --only main # or, during development, install all (virtualenv) user@hostname:~/pagoda$ poetry install Setting-up Backend with docker-compose Install docker-compose command.\nRun middlewares with docker-compose.\nuser@hostname:~/pagoda$ docker-compose up (Setting-up Backend with manual) And you have to install RabbitMQ for executing heavy processing as background task using Celery.\nuser@hostname:~$ sudo apt-get install rabbitmq-server mysql-server python-dev libmysqlclient-dev Setting-up MySQL configuration Specifying character set of database is necessary. Please add following setting in the mysqld.cnf at mysqld section.\n[mysqld] ... character-set-server = utf8mb4 Then, you should restart MySQL server to apply for this configuration.\nuser@hostname:~$ sudo service mysql restart Iincrease the number of Slave databases with the MySQL replication function.\nYou can set database slave, with like this config:\nREPLICATED_DATABASE_SLAVES = [\u0026#39;slave1\u0026#39;, \u0026#39;slave2\u0026#39;] Setting-up Elasticsearch You have to setup JRE for executing elasticsearch.\nuser@hostname:~$ sudo add-apt-repository ppa:linuxuprising/java user@hostname:~$ sudo apt-get update user@hostname:~$ sudo apt-get install -y oracle-java13-installer The way to install elasticsearch is quite easy like that.\nuser@hostname:~$ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.17.6-linux-x86_64.tar.gz user@hostname:~$ tar -xvf elasticsearch-7.17.6-linux-x86_64.tar.gz After installing it, you have to change configuration to accept connecting from Pagoda nodes.\n--- elasticsearch-7.17.6-linux-x86_64/config/elasticsearch.yml.old 2020-01-29 10:19:40.511687943 +0900 +++ elasticsearch-7.17.6-linux-x86_64/config/elasticsearch.yml 2020-01-29 10:41:23.103687943 +0900 @@ -52,7 +52,7 @@ # # Set the bind address to a specific IP (IPv4 or IPv6): # -#network.host: 192.168.0.1 +network.host: 0.0.0.0 # # Set a custom port for HTTP: # You should set sysctl as below because Elasticsearch requires to expand virtual memory area.\nuser@hostname:~$ sudo sysctl vm.max_map_count=262144 Finally, you can run ElasticSearch service like that.\nuser@hostname:~$ elasticsearch-7.17.6-linux-x86_64/bin/elasticsearch Setting-up Email configuration This step is optional. You can skip it if you don\u0026rsquo;t use email notifications.\nPagoda supports email based notification, now it\u0026rsquo;s mainly used for password-reset. You can set email backend, with like this config:\nEMAIL_BACKEND = \u0026#39;django.core.mail.backends.smtp.EmailBackend\u0026#39; EMAIL_HOST = \u0026#39;xxx\u0026#39; EMAIL_PORT = 25 EMAIL_HOST_USER = \u0026#39;xxx\u0026#39; EMAIL_HOST_PASSWORD = \u0026#39;xxx\u0026#39; EMAIL_USE_TLS = True If you hope to just try it in your local environment, you can use stdout instead:\nEMAIL_BACKEND = \u0026#39;django.core.mail.backends.console.EmailBackend\u0026#39; Setting-up Nginx (Optional) Install Nginx by package manager like this.\nuser@hostname:~$ sudo apt-get install nginx Create Self-Signed SSL Certificate and key-pair.\nuser@hostname:~$ openssl genrsa 2048 \u0026gt; server.key user@hostname:~$ openssl req -new -key server.key \u0026gt; server.csr ... (set appropriate configuration) user@hostname:~$ openssl x509 -days 3650 -req -signkey server.key \u0026lt; server.csr \u0026gt; server.crt user@hostname:~$ sudo mkdir /etc/nginx/ssl user@hostname:~$ sudo mv server* /etc/nginx/ssl Write following configuration for Pagoda on Nginx at /etc/nginx/conf.d/pagoda.conf.\nupstream pagoda { server hostname:8080; } server { listen 443 ssl; ssl_certificate /etc/nginx/ssl/server.crt; ssl_certificate_key /etc/nginx/ssl/server.key; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Port 443; location / { rewrite ^/(.*) /$1 break; proxy_pass http://pagoda/; } access_log /var/log/nginx/pagoda.ssl.access.log combined; error_log /var/log/nginx/pagoda.ssl.error.log; # set longer to wait background processing until 300s proxy_read_timeout 300; } This includes the configuration to proxy HTTP request to Pagoda and cache static files. The static file path indicates the static directory which is in the top of Pagoda local repository. If necessary, please fix this value depending on your environment.\nInitialize Pagoda configuratoin You should create user and attach role in Elasticsearch.\nbin/elasticsearch-users useradd airone bin/elasticsearch-users roles airone --add superuser You should cerate database and user for pagoda in MySQL.\nuser@hostname:~$ mysql -u root -h 127.0.0.1 mysql\u0026gt; create database airone; mysql\u0026gt; create database test_airone; mysql\u0026gt; CREATE USER \u0026#39;airone\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; mysql\u0026gt; GRANT ALL ON airone.* to airone@\u0026#39;%\u0026#39;; mysql\u0026gt; GRANT ALL ON test_airone.* to airone@\u0026#39;%\u0026#39;; This command makes database schema using the django Migrations, and makes default user account.\nuser@hostname:~$ cd pagoda user@hostname:~/pagoda$ source virtualenv/bin/activate (virtualenv) user@hostname:~/pagoda$ tools/clear_and_initdb.sh (Optional) Please set the index as necessary.\nmysql\u0026gt; CREATE INDEX permission_codename_idx ON auth_permission (codename); Finally, you should create an initial user to login the system using tools/register_user.sh.\n(virtualenv) user@hostname:~/pagoda$ tools/register_user.sh demo Password: ## input password of this user Succeed in register user (demo) This creates following user.\nUsername Password demo demo If you want to create an administrative user who can access all information regardless of ACL (Please refer the User-Manual(TBD)), you can do it with -s, --superuser option. This creates another user who takes privilege of this system.\n(virtualenv) user@hostname:~/pagoda$ tools/register_user.sh -s admin Password: ## input password of this user Succeed in register user (admin) This regists all entries which has been created in the database to the Elasticsearch.\nYou can do it just by following command. The configurations about the database to read and Elasticsearch to register are referred from airone/settings.py.\n(virtualenv) user@hostname:~/pagoda$ python tools/initialize_es_document.py Run Pagoda You can start Pagoda as following and can browse from http://hostname:8080/\n(Please change the hostname to the appropriate one on which you installed Pagoda). e.g.\nuser@hostname:~$ cd pagoda user@hostname:~/pagoda$ source virtualenv/bin/activate (virtualenv) user@hostname:~/pagoda$ python manage.py runserver 0:8080 Run Celery In addition, you have to run Celery worker to execute background task as following.\nuser@hostname:~$ cd pagoda user@hostname:~/pagoda$ source virtualenv/bin/activate (virtualenv) user@hostname:~/pagoda$ celery -A airone worker -l info Build the new UI with React /ui/ serves React-based new UI. Before you try it, you need to build ui.js:\nInstall nvm command.\nInstall npm packages.\nuser@hostname:~$ nvm install 18.12.0 user@hostname:~$ cd pagoda user@hostname:~/pagoda$ npm install Build\nuser@hostname:~/pagoda$ npm run build (In development) user@hostname:~/pagoda$ npm run watch If you have any change on API V2, you need to run this command before you build:\nuser@hostname:~/pagoda$ npm run generate:client (For Customview) user@hostname:~/pagoda$ npm run generate:custom_client To customize UI:\nuser@hostname:~/pagoda$ cp -pi ./frontend/src/App.tsx ./frontend/src/customview/CustomApp.tsx (edit CustomApp.tsx) user@hostname:~/pagoda$ npm run build:custom API V2 client Prepare to install API client npm package published on GitHub Packages. TOKEN is a your GitHub PAT. Issue your PAT with checking this doc. Then, you just perform npm install as usual.\n$ cat \u0026gt; .npmrc //npm.pkg.github.com/:_authToken=TOKEN You can refer your local API client code before publishing it to GitHub Packages with following command.\n# generate the latest API client code on your local env $ npm run generate:client # refer the latest code temporarily $ npm run link:client If you modify something in API client code, you need to publish it with the package release GitHub Actions workflow. It will be triggered by labeling release-apiv2-client to the pull request by repository owners.\nAuto-format user@hostname:~$ cd pagoda user@hostname:~/pagoda$ source virtualenv/bin/activate (virtualenv) user@hostname:~/pagoda$ ruff format . (virtualenv) user@hostname:~/pagoda$ ruff check --fix . user@hostname:~/pagoda$ npm run fix Test for Django processing You can run tests for processing that is run by Django and Celery, which means backend processing, as below.\nuser@hostname:~$ cd pagoda user@hostname:~/pagoda$ source virtualenv/bin/activate (virtualenv) user@hostname:~/pagoda$ python manage.py test When you want to run a specific test (ModelTest.test_is_belonged_to_parent_group in the file of role/tests/test_model.py) , you can do it as below.\n(virtualenv) user@hostname:~/pagoda$ python manage.py test role.tests.test_model.ModelTest.test_is_belonged_to_parent_group Test for React processing You can run test for processing that is run by Browser, wihch means frontend processing as below.\nuser@hostname:~$ cd pagoda user@hostname:~/pagoda$ npm run test If you have any change on a page component, please re-build snapshots along with current implementaion as below.\nuser@hostname:~/pagoda$ npm run test:update When you want to run individual test (e.g. frontend/src/components/user/UserList.test.tsx), you can do it by following command.\nuser@hostname:~/pagoda$ npx jest -u frontend/src/components/user/UserList.test.tsx Release pagoda-core package for custom views We publish the pagoda-core package to GitHub npm Registry for custom views. When you want to release a new version of the package, create a tag with the format pagoda-core-x.y.z (e.g. pagoda-core-0.0.1). The GitHub Actions workflow will automatically build and publish the package.\nIf you hope to try building the module:\n$ npm run build:lib "}),e.add({id:7,href:"/advanced/advanced_search/",title:"Advanced Search",parent:"Advanced Topics",content:`Advanced Search Advanced Search is a powerful feature that allows you to search across multiple entities and their attributes with various search options and filters.
Features Search Capabilities Cross-Entity Search
Search across multiple entity types simultaneously Filter results by entity type Combine search results from different entities Attribute-Based Search
Search by specific attribute values Support for various data types: Text (string, multi-line text) Numbers Dates and date ranges Boolean values Object references Search Options
Exact match or partial match AND/OR conditions between multiple search criteria Filter by attribute conditions: Empty values Non-empty values Text contains/not contains Date ranges Advanced Features Join Attrs Join Attrs enables relationship traversal in search results. Key points:
Implementation
Sequential processing: root -\u0026gt; join targets Each join triggers new Elasticsearch query Supports OBJECT and ARRAY type references Critical Considerations
Pagination Behavior
# Example: Request 100 items root_results = search(limit=100) # Returns 100 root items joined_results = join_and_filter() # May return 0-100 items next_page_starts_at = 101 # Regardless of joined result size Pagination applies to root level only Join/filter operations may reduce result size Each page may return fewer items than requested Performance Impact
N+1 query pattern with multiple joins No optimization for deep joins with filters Result Count Accuracy
Total count represents root level matches only Actual result count may be lower after joins/filters Cannot predict exact total after joins without full scan Search Chain Follow relationships between entries Search through referenced objects Chain multiple searches to traverse complex relationships Results include both direct matches and related entries Export Functionality Export search results to various formats Asynchronous processing for large result sets Progress tracking for export tasks Download exported files when ready Access Methods Web UI (Legacy) The legacy UI provides a full-featured search interface with:
Interactive search form Real-time search results Advanced filtering options Export capabilities Search chain visualization REST API (APIv2) Access Advanced Search programmatically through REST endpoints:
/api/v2/advanced_search/ - Main search endpoint /api/v2/advanced_search_chain/ - Search chain operations /api/v2/advanced_search_result/ - Export and result management Limitations and Considerations Search Limits Maximum results per query: Configurable, default is 100 entries Export size limits may apply for very large result sets Complex search chains may increase response time Performance Considerations Large result sets are processed asynchronously Complex search chains may require multiple API calls Export operations for large datasets run in the background Access Control Search results respect user permissions Attribute-level access control applies to search results Export operations require appropriate permissions Best Practices Use specific entity and attribute combinations when possible Leverage search chains for complex relationship queries Monitor export task progress for large result sets Consider pagination for large result sets in API usage For Developers Architecture Overview Core Components Service Layer
AdvancedSearchService: Main service class handling search operations Type-safe implementations using Python type hints and Pydantic models Clear separation between data access and business logic Search Engine
Elasticsearch-based implementation Custom index mapping for optimized search Support for nested objects and complex queries Configurable result window and timeout settings Data Models
Entity-Attribute-Value (EAV) pattern for flexible data modeling Versioned attribute values Type-safe attribute value storage Implementation Details Search Process Flow
Query Building: Create Elasticsearch query from search parameters Permission Checking: Apply ACL filters at entity and attribute levels Result Processing: Transform Elasticsearch results to typed models Chain Processing: Handle relationship traversal for search chains Asynchronous Operations
Celery tasks for background processing Export task management and progress tracking Configurable task queues and priorities API Integration REST Endpoints Advanced Search
Endpoint: /api/v2/advanced_search/ Supports complex search parameters Returns paginated, typed results Handles ACL filtering Search Chain
Endpoint: /api/v2/advanced_search_chain/ Manages relationship traversal Supports multiple chain steps Combines results across relationships Export Management
Endpoint: /api/v2/advanced_search_result/ Handles asynchronous export requests Provides task status monitoring Manages file downloads Response Types Strongly typed response models using Pydantic Consistent error handling Support for various result formats Development Guidelines Adding New Features Extend search capabilities through service layer Maintain type safety with Pydantic models Follow existing patterns for ACL integration Add appropriate test coverage Performance Optimization Use appropriate Elasticsearch index settings Implement efficient query patterns Consider bulk operations for large datasets Leverage caching where appropriate Testing Unit tests for service layer Integration tests for API endpoints Performance tests for search operations ACL verification tests `}),e.add({id:8,href:"/advanced/categories/",title:"Categories",parent:"Advanced Topics",content:`Categories Categories in Pagoda help you organize and group related entities for easier navigation and management. Think of categories as customizable collections of links to your entity sets.
Features Flexible Grouping: Create categories to group related entities together Multiple Entity Association: Link multiple entities to a single category Search \u0026amp; Filter: Quickly find categories using the search functionality Priority Setting: Control the display order of categories Notes: Add descriptions or additional information to categories Managing Categories Creating a Category Click the \u0026ldquo;Create New Category\u0026rdquo; button Fill in the required information: Name: Category identifier Notes: Additional information or description Models: Select one or more entities to include Priority: Set display order (lower numbers appear first) Viewing Categories Categories are displayed in a grid layout, showing:
Category name Associated entity links Quick access to entity data Searching Categories Use the search box to filter categories by name.
Editing Categories Click the menu icon (⋮) on a category card to:
Edit category details Delete the category `}),e.add({id:9,href:"/advanced/frontend/",title:"Frontend",parent:"Advanced Topics",content:`Frontend Architecture Pagoda provides two distinct user interfaces: a modern React-based SPA (New UI) and a traditional Django template-based interface (Legacy UI). This document explains both interfaces, their features, and how to work with them.
For Users Overview New UI (React SPA) Modern, responsive single-page application Fast, client-side navigation Real-time updates and validations Consistent look and feel using Material-UI Internationalization support Legacy UI (Django Templates) Traditional server-side rendered pages Direct database operations Stable and proven interface Simpler architecture for basic operations Key Features Common Features Entity and attribute management User and group administration Access control management Advanced search capabilities History tracking Webhook management New UI Specific Features Improved response times through API-based operations Modern form handling with real-time validation Enhanced user experience with instant feedback Consistent styling across all pages Mobile-friendly responsive design Legacy UI Specific Features Direct database operations Server-side validation Traditional navigation pattern Simpler debugging process When to Use Which UI Use New UI When Working with modern browsers Requiring real-time feedback Needing mobile-friendly interface Performing complex data operations Integrating with other modern web applications Use Legacy UI When Requiring simpler, proven interface Working in environments with limited JavaScript support Needing direct database operations Performing basic CRUD operations For Developers Architecture Overview New UI Architecture Core Technologies React 18 TypeScript Material-UI (MUI) react-router for routing react-hook-form for form management zod for schema validation i18next for internationalization Directory Structure frontend/src/ ├── apiclient/ # API client wrapper ├── components/ # Reusable UI components ├── hooks/ # Custom React hooks ├── i18n/ # Internationalization ├── pages/ # Page components ├── repository/ # Data access layer ├── routes/ # Routing configuration └── services/ # Business logic Key Components API Client: Auto-generated from OpenAPI specs Form Management: react-hook-form with zod validation State Management: React hooks and context Routing: react-router with type-safe routes UI Components: Material-UI based components Legacy UI Architecture Core Technologies Django Templates jQuery (where needed) Bootstrap for styling Template Structure templates/ ├── advanced_search/ # Search interface ├── edit_entry/ # Entry management ├── list_entry/ # Entry listing ├── registration/ # User registration ├── role/ # Role management └── show_entry/ # Entry display Development Guidelines Setting Up Development Environment # Install dependencies npm install # Start development server npm run watch # Build for production npm run build:production Adding New Features New UI Development
Follow React component patterns Use TypeScript for type safety Implement responsive design Add appropriate test coverage Update API client when needed Legacy UI Development
Follow Django template patterns Maintain backwards compatibility Keep JavaScript usage minimal Test across different browsers Testing New UI Testing
Unit tests with Jest Component testing with React Testing Library E2E testing when needed i18n testing Legacy UI Testing
Django template testing Integration testing Browser compatibility testing Performance Considerations New UI Use React.memo for expensive components Implement proper code splitting Optimize bundle size Use appropriate caching strategies Legacy UI Minimize server-side processing Optimize template rendering Use appropriate caching Minimize database queries `}),e.add({id:10,href:"/categories/",title:"Categories",parent:"Pagoda",content:""}),e.add({id:11,href:"/advanced/custom_view/",title:"CustomView",parent:"Advanced Topics",content:`Custom View Overview Custom Views in Pagoda allow developers to extend the standard UI with their own React-based interfaces. This feature enables you to create specialized views that leverage Pagoda\u0026rsquo;s core functionality while providing tailored user experiences for specific use cases.
By using Custom Views, you can build interfaces that:
Present data in specialized formats Implement domain-specific workflows Integrate with Pagoda\u0026rsquo;s data model and ACL system Provide alternative navigation or interaction patterns What You Can Do with Custom Views Custom Views enable you to:
Create specialized interfaces: Build custom dashboards, data visualizations, or domain-specific tools Integrate with Pagoda\u0026rsquo;s core: Access and manipulate data using Pagoda\u0026rsquo;s data models and services Implement custom logic: Add business logic specific to your use case Extend the UI: Provide alternative ways to view and interact with your data Relationship with Pagoda Core Custom Views are built as React applications that integrate with Pagoda through the PagodaProvider component. This provider gives your Custom View access to:
Pagoda\u0026rsquo;s data models (Entity-Attribute-Value pattern) Authentication and authorization Search capabilities Other core services The Pagoda Core (@dmm-com/pagoda-core) is bundled as a library that your Custom View can import and use, allowing you to focus on building your specific interface rather than reimplementing core functionality. This package is hosted on GitHub Registry at https://github.com/dmm-com/pagoda/pkgs/npm/pagoda-core.
Note: Since @dmm-com/pagoda-core is hosted on GitHub Registry, you\u0026rsquo;ll need to configure npm to access GitHub packages. Make sure you have appropriate GitHub access and authentication set up before installing the package.
Getting Started with Custom View Development Prerequisites Node.js (v16 or later) npm (v7 or later) Basic knowledge of React and TypeScript GitHub access (for installing @dmm-com/pagoda-core from GitHub Registry) Step 1: Configure npm for GitHub Registry Before installing dependencies, configure npm to access the GitHub Registry:
# Create or edit .npmrc in your project root echo \u0026#34;@dmm-com:registry=https://npm.pkg.github.com\u0026#34; \u0026gt;\u0026gt; .npmrc # Authenticate with GitHub (you\u0026#39;ll need a personal access token with appropriate permissions) npm login --registry=https://npm.pkg.github.com --scope=@dmm-com Step 2: Clone the Example Project Start by cloning the example Custom View project:
git clone https://github.com/syucream/pagoda-customview-example cd pagoda-customview-example Step 3: Install Dependencies Install the required dependencies:
npm install Step 4: Run the Development Server Start the development server:
npm run dev This will:
Start a local development server (typically at http://localhost:5173) Enable hot module replacement for quick development Watch for file changes and automatically rebuild Step 5: Understand the Project Structure The example project demonstrates:
How to use the PagodaProvider to integrate with Pagoda Basic project structure for a Custom View How to access Pagoda\u0026rsquo;s core functionality Step 6: Build Your Custom View When building your own Custom View:
Wrap your application with PagodaProvider Use Pagoda\u0026rsquo;s core services to access and manipulate data Implement your custom UI components Add any additional business logic specific to your use case Step 7: Build for Production When ready to deploy:
npm run build This will create a production-ready build of your Custom View that can be integrated with Pagoda.
Development Notes The development server supports hot reloading - changes will be reflected immediately in the browser TypeScript errors will be shown in both the terminal and browser console The application integrates with Pagoda Core for base functionality Example Use Cases Specialized Data Visualization: Create custom charts or graphs for your data Domain-Specific Workflows: Implement guided workflows for specific business processes Alternative Navigation: Provide different ways to browse and search your data Integration with External Systems: Connect Pagoda data with other systems or APIs By leveraging Custom Views, you can extend Pagoda\u0026rsquo;s capabilities while maintaining the benefits of its core data management and ACL systems.
`}),e.add({id:12,href:"/getting_started/",title:"Getting Started",parent:"Pagoda",content:""}),e.add({id:13,href:"/",title:"Pagoda",parent:"",content:` Pagoda is a Web Application which is developed by the infrastructure division of DMM.com LLC on the purpose of managing information which is associated with on-premise equipments. This aims to be versatile and flexible for doing it.
In regard to the DMM.com, Pagoda is responsible for managing all phisical (e.g. where a Server is equipped on), logical (e.g. which IPv4/v6 addresses are binded to), managemental (e.g. accounting details for equipments), operational (e.g. who and how uses it) information. And this meets demands of individual departs departments that handle each different information and have own work styles.
We had managed those information by using a DCIM (a.k.a. Data Center Information Management) system and many spreadsheets which are related to it until then. Basic physical and logical information was managed in the DCIM. And other spreadsheets had related managemental and operational information. Sadly, there were many different similer spreadsheets that have same information.
When it comes to a equipments of Server, Data Center team has an interest in what kind of transceivers (SFP?, SFP+? or QSFP?) are installed on its ports. On the other hand, Contents Provider team is interested in storage devices on it. And Accounting team cares when they and how they were purchased. Please imagine a situation that individual teams try to handle those information by own spreadsheets. It\u0026rsquo;s nightmare to keep consistency of all those spreadsheets once its physical (this Server) would be disposed.
The original motivation of developing this software is solving this problem. If you are interested in more information about it, please check below page. (https://www.janog.gr.jp/meeting/janog45/en/program/infrabcp)
`}),e.add({id:14,href:"/getting_started/overview/",title:"Pagoda Overview",parent:"Getting Started",content:`Pagoda is an information management system with high flexibility of access control and high extensibility of data. This enables to manage information in any type of use-cases. This document describes these features.
Data model that meets with extensibility Pagoda manages informaiton by using following two type of data-structure.
Entity - has meta data (what kind of data it has and how). Entry - has actual data in conformity to an Entity which is associated with it. This page shows an example how to manage information which has complex data-structure in this system as an example of an information management system of a library. This system manages book location information (where book is arranged in), book management information (what kind book is registered) and lending information (which book is lent to whom). The following an E-R diagram that descfribes the data-model of this system.
You can easily manage those complex information by making Entities on Pagoda as below.
And by making Entries, you can register and retrieve all kind of data instances which are mentioned above.
In this way, user can handle any kind of information and information which is associated with other ones by using this simple data-structure (Entity and Entry) other than above use-case. For more information about this Pagoda\u0026rsquo;s datastructure, please see Entity and Entry page.
`}),e.add({id:15,href:"/tags/",title:"Tags",parent:"Pagoda",content:""})})()